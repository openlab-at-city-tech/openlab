{"version":3,"file":"./build/rich-text/index.min.js","mappings":"mBACA,IAAIA,EAAsB,CCA1B,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClF,EAAyBT,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,M,6lCCLvD,MAAM,EAA+BC,OAAW,GAAQ,KCAlD,EAA+BA,OAAe,OCgCpD,GAAeC,EAAAA,EAAAA,iBAAiB,CAAEC,YAd3B,WAA2C,IAArBC,EAAqB,uDAAb,GAAIC,EAAS,uCACjD,OAASA,EAAOC,MACf,IAAK,mBACJ,MAAO,IACHF,MACAG,EAAAA,EAAAA,OAAOF,EAAOF,YAAa,SAEhC,IAAK,sBACJ,OAAOK,EAAAA,EAAAA,MAAMJ,EAAOC,EAAOI,OAG7B,OAAOL,KCWR,IAAIM,EAAW,GAWf,SAASC,EAAQX,GAChB,MAAO,CAACA,GAyCT,SAASY,EAAeC,EAAGC,EAAGC,GAC7B,IAAIC,EAEJ,GAAIH,EAAEI,SAAWH,EAAEG,OAClB,OAAO,EAGR,IAAKD,EAAID,EAAWC,EAAIH,EAAEI,OAAQD,IACjC,GAAIH,EAAEG,KAAOF,EAAEE,GACd,OAAO,EAIT,OAAO,EC7FD,MAAME,ED8GE,SAAUC,EAAUC,GAElC,IAAIC,EAGAC,ECjHFlB,CAAAA,GAAW,CAAEA,EAAMD,eDiHyCQ,EAoB9D,SAASY,EAASC,GACjB,IAECR,EACAS,EACAC,EACAC,EA3FmB3B,EAsFhB4B,EAASP,EACZQ,GAAuB,EAMxB,IAAKb,EAAI,EAAGA,EAAIQ,EAAWP,OAAQD,IAAK,CAIvC,KAjGmBhB,EA8FnByB,EAAYD,EAAWR,KA7FP,iBAAoBhB,EAgGN,CAC7B6B,GAAuB,EACvB,MAIGD,EAAOE,IAAIL,GAEdG,EAASA,EAAOpC,IAAIiC,IAGpBC,EAAM,IAAIK,QACVH,EAAOI,IAAIP,EAAWC,GACtBE,EAASF,GAYX,OANKE,EAAOE,IAAIpB,MACfiB,EA5GH,WAEC,IAAIA,EAAQ,CACXM,MAAO,WACNN,EAAMO,KAAO,OAIf,OAAOP,EAoGGQ,IACFN,qBAAuBA,EAC7BD,EAAOI,IAAItB,EAAUiB,IAGfC,EAAOpC,IAAIkB,GAMnB,SAASuB,IACRZ,EAAY,IAAIU,QAcjB,SAASK,IACR,IACCT,EACAU,EACArB,EACAsB,EACAd,EALGe,EAAMC,UAAUvB,OASpB,IADAqB,EAAO,IAAIG,MAAMF,GACZvB,EAAI,EAAGA,EAAIuB,EAAKvB,IACpBsB,EAAKtB,GAAKwB,UAAUxB,GAqBrB,KAjBAW,EAAQJ,EADRC,EAAaF,EAAwBoB,MAAM,KAAMJ,KAMtCT,uBAETF,EAAMgB,iBACL/B,EAAeY,EAAYG,EAAMgB,eAAgB,IAElDhB,EAAMM,QAGPN,EAAMgB,eAAiBnB,GAGxBa,EAAOV,EAAMO,KACNG,GAAM,CAEZ,GAAKzB,EAAeyB,EAAKC,KAAMA,EAAM,GAsBrC,OAdID,IAASV,EAAMO,OAEQG,EAAS,KAAEO,KAAOP,EAAKO,KAC7CP,EAAKO,OACRP,EAAKO,KAAKC,KAAOR,EAAKQ,MAGvBR,EAAKO,KAAOjB,EAAMO,KAClBG,EAAKQ,KAAO,KACclB,EAAU,KAAEkB,KAAOR,EAC7CV,EAAMO,KAAOG,GAIPA,EAAKS,IArBXT,EAAOA,EAAKO,KA8Cd,OApBAP,EAAgC,CAE/BS,IAAK3B,EAASuB,MAAM,KAAMJ,IAI3BA,EAAK,GAAK,KACVD,EAAKC,KAAOA,EAMRX,EAAMO,OACTP,EAAMO,KAAKW,KAAOR,EAClBA,EAAKO,KAAOjB,EAAMO,MAGnBP,EAAMO,KAAOG,EAENA,EAAKS,IAOb,OAJAV,EAAahB,cAAgBE,EAC7Bc,EAAaH,MAAQA,EACrBA,IAE2C,ECzRdc,EAC3B3C,GAAWf,OAAO2D,OAAQ5C,EAAMD,eAY5B,SAAS8C,EAAe7C,EAAO8C,GACrC,OAAO9C,EAAMD,YAAa+C,GAYpB,SAASC,EAA6B/C,EAAOgD,GACnD,OAAOC,EAAAA,EAAAA,MAAMnC,EAAgBd,IAAS,IAA8B,IAA5B,UAAEkD,EAAF,QAAaC,GAAe,EACnE,OAAqB,OAAdD,GAAsBF,IAAuBG,KAY/C,SAASC,EAA2BpD,EAAOqD,GACjD,OAAOJ,EAAAA,EAAAA,MAAMnC,EAAgBd,IAAS,IAAqB,IAAnB,UAAEkD,GAAiB,EAC1D,OAAmB,OAAdA,GAIG,IAAIG,KAAqBC,QAAU,IAAIJ,OAAmB,KC9C7D,SAASK,EAAgBxD,GAC/B,MAAO,CACNG,KAAM,mBACNH,aAAayD,EAAAA,EAAAA,WAAWzD,IAWnB,SAAS0D,EAAmBpD,GAClC,MAAO,CACNH,KAAM,sBACNG,OAAOmD,EAAAA,EAAAA,WAAWnD,IClBpB,MASaqD,GAAQC,EAAAA,EAAAA,kBATF,iBASgC,CAClDC,QADkD,EAElDC,UAFkD,EAGlDC,QAAOA,ICdD,SAASC,EAAeC,EAASC,GAEvC,GAAKD,IAAYC,EAChB,OAAO,EAIR,IAAOD,IAAaC,EACnB,OAAO,EAGR,GAAKD,EAAQ9D,OAAS+D,EAAQ/D,KAC7B,OAAO,EAGR,MAAMgE,EAAcF,EAAQG,WACtBC,EAAcH,EAAQE,WAG5B,GAAKD,IAAgBE,EACpB,OAAO,EAIR,IAAOF,IAAiBE,EACvB,OAAO,EAGR,MAAMC,EAAQpF,OAAOqF,KAAMJ,GACrBK,EAAQtF,OAAOqF,KAAMF,GAE3B,GAAKC,EAAMxD,SAAW0D,EAAM1D,OAC3B,OAAO,EAGR,MAAMA,EAASwD,EAAMxD,OAGrB,IAAM,IAAID,EAAI,EAAGA,EAAIC,EAAQD,IAAM,CAClC,MAAMkC,EAAOuB,EAAOzD,GAEpB,GAAKsD,EAAapB,KAAWsB,EAAatB,GACzC,OAAO,EAIT,OAAO,ECxCD,SAAS0B,EAAkB5E,GACjC,MAAM6E,EAAa7E,EAAM8E,QAAQC,QAoBjC,OAlBAF,EAAWG,SAAS,CAAEC,EAAgBC,KACrC,MAAMC,EAAyBN,EAAYK,EAAQ,GAEnD,GAAKC,EAAyB,CAC7B,MAAMC,EAAoBH,EAAeF,QAEzCK,EAAkBJ,SAAS,CAAEK,EAAQC,KACpC,MAAMC,EAAiBJ,EAAwBG,GAE1CnB,EAAekB,EAAQE,KAC3BH,EAAmBE,GAAgBC,MAIrCV,EAAYK,GAAUE,MAIjB,IACHpF,EACH8E,QAASD,GCxBX,SAASW,EAASC,EAAOP,EAAOlF,GAG/B,OAFAyF,EAAQA,EAAMV,SACPG,GAAUlF,EACVyF,EAeD,SAASC,EACf1F,EACAqF,GAGC,IAFDM,EAEC,uDAFY3F,EAAM4F,MACnBC,EACC,uDADU7F,EAAM8F,IAEjB,MAAM,QAAEhB,EAAF,cAAWiB,GAAkB/F,EAC7B6E,EAAaC,EAAQC,QAG3B,GAAKY,IAAeE,EAAW,CAC9B,MAAMG,GAAc3C,EAAAA,EAAAA,MAAMwB,EAAYc,GAAc,CACnDrF,KAAM+E,EAAO/E,OAKd,GAAK0F,EAAc,CAClB,MAAMd,EAAQL,EAAYc,GAAajC,QAASsC,GAEhD,KACCnB,EAAYc,IACZd,EAAYc,GAAcT,KAAYc,GAEtCnB,EAAYc,GAAeH,EAC1BX,EAAYc,GACZT,EACAG,GAEDM,IAKD,IAFAE,IAGChB,EAAYgB,IACZhB,EAAYgB,GAAYX,KAAYc,GAEpCnB,EAAYgB,GAAaL,EACxBX,EAAYgB,GACZX,EACAG,GAEDQ,SAGI,CAEN,IAAII,EAAW,IAEf,IAAM,IAAIf,EAAQS,EAAYT,EAAQW,EAAUX,IAC/C,GAAKL,EAAYK,GAAU,CAC1BL,EAAYK,GAAUL,EAAYK,GAAQgB,QACzC,QAAE,KAAE5F,GAAJ,SAAgBA,IAAS+E,EAAO/E,QAGjC,MAAMW,EAAS4D,EAAYK,GAAQjE,OAE9BA,EAASgF,IACbA,EAAWhF,QAGZ4D,EAAYK,GAAU,GACtBe,EAAW,EAIb,IAAM,IAAIf,EAAQS,EAAYT,EAAQW,EAAUX,IAC/CL,EAAYK,GAAQiB,OAAQF,EAAU,EAAGZ,GAI3C,OAAOT,EAAkB,IACrB5E,EACH8E,QAASD,EAITkB,cAAe,KACXK,EAAAA,EAAAA,QAAQL,EAAe,CAAEzF,KAAM+E,EAAO/E,OACzC+E,KCrGI,SAASgB,EAAT,EAA4CC,GAAO,IAA3B,eAAEC,GAAyB,EAWzD,OANOF,EAAcG,OACpBH,EAAcG,KAAOD,EAAeE,mBAAoB,IAAKD,MAG9DH,EAAcG,KAAKE,UAAYJ,EAExBD,EAAcG,MJItBG,EAAAA,EAAAA,UAAU7C,GKxBH,MAAM8C,EAAiB,SAKjBC,EAA+B,ICqC5C,SAASC,EAAT,GAA0C,IACrCC,GADc,KAAEzG,EAAF,WAAQiE,GAAe,EAyBzC,GAtBKA,GAAcA,EAAWyC,QAC7BD,GAAaE,EAAAA,EAAAA,QAAQC,GAAgB1D,0BACpCe,EAAWyC,OAGPD,IAEJxC,EAAWyC,MAAS,IAAIzC,EAAWyC,SACjCxB,QAAU,IAAIuB,EAAWzD,aAAe,KACxC6D,OAEK5C,EAAWyC,cACVzC,EAAWyC,QAKdD,IACNA,GACCE,EAAAA,EAAAA,QAAQC,GAAgB/D,4BAA6B7C,KAGhDyG,EACN,OAAOxC,EAAa,CAAEjE,KAAAA,EAAMiE,WAAAA,GAAe,CAAEjE,KAAAA,GAG9C,GACCyG,EAAWK,0CACTL,EAAWM,0CAEb,OAAO,KAGR,IAAO9C,EACN,MAAO,CAAEjE,KAAMyG,EAAW7D,MAG3B,MAAMoE,EAAuB,GACvBC,EAAyB,GACzBC,EAAc,IAAKjD,GAEzB,IAAM,MAAMpF,KAAO4H,EAAWxC,WAAa,CAC1C,MAAMrB,EAAO6D,EAAWxC,WAAYpF,GAEpCmI,EAAsBnI,GAAQqI,EAAatE,GAEtC6D,EAAWU,iCACfH,EAAsBnI,GACrB4H,EAAWU,+BACVtI,EACAmI,EAAsBnI,YAMlBqI,EAAatE,QAEwB,IAAhCoE,EAAsBnI,WAC1BmI,EAAsBnI,GAI/B,IAAM,MAAM+D,KAAQsE,EACnBD,EAAwBrE,GAASqB,EAAYrB,GAG9C,MAAO,CACN5C,KAAMyG,EAAW7D,KACjBqB,WAAY+C,EACZC,uBAAAA,GA+CK,SAASG,IASP,IATe,QACvBC,EADuB,KAEvBC,EAFuB,KAGvBtB,EAHuB,MAIvBuB,EAJuB,aAKvBC,EALuB,qBAMvBC,EACAC,yBAA0BC,EAPH,mBAQvBC,GACQ,uDAAL,GACH,MAAqB,iBAATN,GAAqBA,EAAK3G,OAAS,EACvC,CACN6D,QAASrC,MAAOmF,EAAK3G,QACrBkH,aAAc1F,MAAOmF,EAAK3G,QAC1B2G,KAAAA,IAImB,iBAATtB,GAAqBA,EAAKrF,OAAS,IAG9C0G,EAAUtB,EAAe+B,SAAU9B,IAGZ,iBAAZqB,EAvJL,CACN7C,QAAS,GACTqD,aAAc,GACdP,KAAM,IAwJAE,EASAO,EAA4B,CAClCV,QAAAA,EACAE,MAAAA,EACAC,aAAAA,EACAC,qBAAAA,EACAE,eAAAA,EACAC,mBAAAA,IAdOI,EAAmB,CACzBX,QAAAA,EACAE,MAAAA,EACAI,eAAAA,EACAC,mBAAAA,KAuBH,SAASK,EAAqBC,EAAanG,EAAMwF,EAAO7H,GACvD,IAAO6H,EACN,OAGD,MAAM,WAAEY,GAAepG,GACjB,eAAEqG,EAAF,YAAkBC,EAAlB,aAA+BC,EAA/B,UAA6CC,GAAchB,EAC3DiB,EAAgBN,EAAYZ,KAAK3G,YAGlB8H,IAAhB/I,EAAM4F,MACV4C,EAAY5C,MAAQkD,EAAgB9I,EAAM4F,MAE/BvD,IAASqG,GAAkBrG,EAAK2G,WAAa3G,EAAK4G,UAC7DT,EAAY5C,MAAQkD,EAAgBH,EAGpCF,IAAeC,GACfrG,IAASqG,EAAeQ,WAAYP,GAEpCH,EAAY5C,MAAQkD,EAGpBL,IAAeC,GACfrG,IAASqG,EAAeQ,WAAYP,EAAc,GAElDH,EAAY5C,MAAQkD,EAAgB9I,EAAM4H,KAAK3G,OAEpCoB,IAASqG,IACpBF,EAAY5C,MAAQkD,QAIFC,IAAd/I,EAAM8F,IACV0C,EAAY1C,IAAMgD,EAAgB9I,EAAM8F,IAE7BzD,IAASuG,GAAgBvG,EAAK2G,WAAa3G,EAAK4G,UAC3DT,EAAY1C,IAAMgD,EAAgBD,EAGlCJ,IAAeG,GACfvG,IAASuG,EAAaM,WAAYL,EAAY,GAE9CL,EAAY1C,IAAMgD,EAAgB9I,EAAM4H,KAAK3G,OAG7CwH,IAAeG,GACfvG,IAASuG,EAAaM,WAAYL,GAElCL,EAAY1C,IAAMgD,EAEPzG,IAASuG,IACpBJ,EAAY1C,IAAMgD,EAAgBD,GAapC,SAASM,EAAa9G,EAAMwF,EAAO3B,GAClC,IAAO2B,EACN,OAGD,MAAM,eAAEa,EAAF,aAAkBE,GAAiBf,EACzC,IAAI,YAAEc,EAAF,UAAeE,GAAchB,EAUjC,OARKxF,IAASqG,IACbC,EAAczC,EAAQ7D,EAAK+G,UAAUrE,MAAO,EAAG4D,IAAgB1H,QAG3DoB,IAASuG,IACbC,EAAY3C,EAAQ7D,EAAK+G,UAAUrE,MAAO,EAAG8D,IAAc5H,QAGrD,CAAEyH,eAAAA,EAAgBC,YAAAA,EAAaC,aAAAA,EAAcC,UAAAA,GASrD,SAASQ,EAAoBC,GAC5B,OAAOA,EAAO9D,QAAS,aAAc,KAQ/B,SAAS+D,EAA0BD,GAEzC,OAAOA,EAAO9D,QACb,IAAIgE,OAAS,YAAiD,MAC9D,IAqBF,SAASlB,EAAT,GAQI,IARwB,QAC3BX,EAD2B,MAE3BE,EAF2B,aAG3BC,EAH2B,qBAI3BC,EAJ2B,mBAK3B0B,EAAqB,GALM,eAM3BxB,EAN2B,mBAO3BC,GACG,EACH,MAAMM,EA5TC,CACN1D,QAAS,GACTqD,aAAc,GACdP,KAAM,IA2TP,IAAOD,EACN,OAAOa,EAGR,IAAOb,EAAQ+B,gBAEd,OADAnB,EAAqBC,EAAab,EAASE,EAnUrC,CACN/C,QAAS,GACTqD,aAAc,GACdP,KAAM,KAiUCY,EAGR,MAAMvH,EAAS0G,EAAQuB,WAAWjI,OAGlC,IAAM,IAAIiE,EAAQ,EAAGA,EAAQjE,EAAQiE,IAAU,CAC9C,MAAM7C,EAAOsF,EAAQuB,WAAYhE,GAC3B5E,EAAO+B,EAAKsH,SAASC,cAE3B,GAAKvH,EAAK2G,WAAa3G,EAAK4G,UAAY,CACvC,IAAI/C,EAASqD,EAENrB,IACNhC,EAAWoD,GACVC,EAA0BF,EAAoBC,KAGhD,MAAM1B,EAAO1B,EAAQ7D,EAAK+G,WAC1BvB,EAAQsB,EAAa9G,EAAMwF,EAAO3B,GAClCqC,EAAqBC,EAAanG,EAAMwF,EAAO,CAAED,KAAAA,IAGjDY,EAAY1D,QAAQ7D,QAAU2G,EAAK3G,OACnCuH,EAAYL,aAAalH,QAAU2G,EAAK3G,OACxCuH,EAAYZ,MAAQA,EACpB,SAGD,GAAKvF,EAAK2G,WAAa3G,EAAKwH,aAC3B,SAGD,GACC5B,IAEE5F,EAAKyH,aAAc,+BAET,OAATxJ,IACC+B,EAAKyH,aAAc,8BACtB,CACDvB,EAAqBC,EAAanG,EAAMwF,EA7WnC,CACN/C,QAAS,GACTqD,aAAc,GACdP,KAAM,KA2WL,SAGD,GAAc,WAATtH,EAAoB,CACxB,MAAMN,EAAQ,CACb8E,QAAS,CAAC,GACVqD,aAAc,CACb,CACC7H,KAAAA,EACAiE,WAAY,CACX,wBACClC,EAAKyH,aAAc,0BACnBC,mBAAoB1H,EAAKqE,cAI7BkB,KAAMf,GAEP0B,EAAqBC,EAAanG,EAAMwF,EAAO7H,GAC/CgK,EAAWxB,EAAaxI,GACxB,SAGD,GAAc,OAATM,EAAgB,CACpBiI,EAAqBC,EAAanG,EAAMwF,EAtYnC,CACN/C,QAAS,GACTqD,aAAc,GACdP,KAAM,KAoYLoC,EAAWxB,EAAad,EAAQ,CAAEE,KAAM,QACxC,SAGD,MAAMvC,EAASyB,EAAU,CACxBxG,KAAAA,EACAiE,WAAY0F,EAAe,CAAEtC,QAAStF,MAGvC,GACC0F,IAC0C,IAA1CA,EAAqBrE,QAASpD,GAC7B,CACD,MAAMN,EAAQqI,EAA4B,CACzCV,QAAStF,EACTwF,MAAAA,EACAC,aAAAA,EACAC,qBAAAA,EACA0B,mBAAoB,IAAKA,EAAoBpE,GAC7C4C,eAAAA,EACAC,mBAAAA,IAGDK,EAAqBC,EAAanG,EAAMwF,EAAO7H,GAC/CgK,EAAWxB,EAAaxI,GACxB,SAGD,MAAMA,EAAQsI,EAAmB,CAChCX,QAAStF,EACTwF,MAAAA,EACAC,aAAAA,EACAC,qBAAAA,EACAE,eAAAA,EACAC,mBAAAA,IAKD,GAFAK,EAAqBC,EAAanG,EAAMwF,EAAO7H,GAExCqF,EAEA,GAA2B,IAAtBrF,EAAM4H,KAAK3G,OACjBoE,EAAOd,YACXyF,EAAWxB,EAAa,CACvB1D,QAAS,CAAC,GACVqD,aAAc,CAAE9C,GAChBuC,KAAMf,QAGF,CAGN,SAASqD,EAAcpF,GACtB,GAAKoF,EAAapF,UAAYA,EAC7B,OAAOoF,EAAarF,WAGrB,MAAMA,EAAaC,EAChB,CAAEO,KAAWP,GACb,CAAEO,GAKL,OAHA6E,EAAapF,QAAUA,EACvBoF,EAAarF,WAAaA,EAEnBA,EAKRqF,EAAarF,WAAa,CAAEQ,GAE5B2E,EAAWxB,EAAa,IACpBxI,EACH8E,QAASrC,MAAM0H,KAAMnK,EAAM8E,QAASoF,UAjCrCF,EAAWxB,EAAaxI,GAsC1B,OAAOwI,EAsBR,SAASH,EAAT,GAQI,IARiC,QACpCV,EADoC,MAEpCE,EAFoC,aAGpCC,EAHoC,qBAIpCC,EAJoC,mBAKpC0B,EAAqB,GALe,eAMpCxB,EANoC,mBAOpCC,GACG,EACH,MAAMM,EApfC,CACN1D,QAAS,GACTqD,aAAc,GACdP,KAAM,IAmfP,IAAOD,IAAaA,EAAQ+B,gBAC3B,OAAOlB,EAGR,MAAMvH,EAAS0G,EAAQyC,SAASnJ,OAGhC,IAAM,IAAIiE,EAAQ,EAAGA,EAAQjE,EAAQiE,IAAU,CAC9C,MAAM7C,EAAOsF,EAAQyC,SAAUlF,GAE/B,GAAK7C,EAAKsH,SAASC,gBAAkB9B,EACpC,SAGD,MAAM9H,EAAQsI,EAAmB,CAChCX,QAAStF,EACTwF,MAAAA,EACAC,aAAAA,EACAC,qBAAAA,EACA0B,mBAAAA,EACAxB,eAAAA,EACAC,mBAAAA,KAIc,IAAVhD,GAAeuE,EAAmBxI,OAAS,IAC/C+I,EAAWxB,EAAa,CACvB1D,QAAS,CAAC,GACVqD,aACCsB,EAAmBxI,OAAS,EACzB,CAAEwI,GACF,CAAC,GACL7B,KAAMhB,IAIR2B,EAAqBC,EAAanG,EAAMwF,EAAO7H,GAC/CgK,EAAWxB,EAAaxI,GAGzB,OAAOwI,EAYR,SAASyB,EAAT,GAAsC,IAAd,QAAEtC,GAAY,EACrC,IAAOA,EAAQ0C,gBACd,OAGD,MAAMpJ,EAAS0G,EAAQpD,WAAWtD,OAClC,IAAIuH,EAGJ,IAAM,IAAIxH,EAAI,EAAGA,EAAIC,EAAQD,IAAM,CAClC,MAAM,KAAEkC,EAAF,MAAQlD,GAAU2H,EAAQpD,WAAYvD,GAED,IAAtCkC,EAAKQ,QAAS,qBAQnB8E,EAAcA,GAAe,GAC7BA,EALiB,OAAO8B,KAAMpH,GAC3B,0BAA4BA,EAC5BA,GAGuBlD,GAG3B,OAAOwI,ECtlBD,SAASwB,EAAWnJ,EAAGC,GAK7B,OAJAD,EAAEiE,QAAUjE,EAAEiE,QAAQyF,OAAQzJ,EAAEgE,SAChCjE,EAAEsH,aAAetH,EAAEsH,aAAaoC,OAAQzJ,EAAEqH,cAC1CtH,EAAE+G,MAAQ9G,EAAE8G,KAEL/G,EAWD,SAAS0J,IAAoB,2BAATvH,EAAS,yBAATA,EAAS,gBACnC,OAAO4B,EAAkB5B,EAAOwH,OAAQR,EAAWtC,MCvB7C,SAAS+C,EAAT,GAGL,IAFD,QAAE3F,EAAF,MAAWc,EAAX,IAAkBE,EAAlB,cAAuBC,GAEtB,EADD2E,EACC,uDADsB,GAEvB,QAAe3B,IAAVnD,EACJ,OAAO8E,EAGR,GAAK9E,IAAUE,EAAM,CAEpB,GAAKC,EACJ,OAAOA,EAGR,MAAM4E,EAAgB7F,EAASc,EAAQ,IAAO8E,EACxCE,EAAe9F,EAASc,IAAW8E,EAKzC,OAAKC,EAAc1J,OAAS2J,EAAa3J,OACjC0J,EAGDC,EAGR,OAAO9F,EAASc,IAAW8E,ECZrB,SAASG,EAAiB7K,EAAO+G,GACvC,OAAO1D,EAAAA,EAAAA,MAAMoH,EAAkBzK,GAAS,CAAEM,KAAMyG,ICZ1C,SAAS+D,EAAT,GAA+D,IAArC,MAAElF,EAAF,IAASE,EAAT,aAAcqC,EAAd,KAA4BP,GAAS,EACrE,GAAKhC,EAAQ,IAAME,GAAO8B,EAAMhC,KAAYiB,EAI5C,OAAOsB,EAAcvC,GCHf,SAASmF,EAAT,GAAoC,IAAX,KAAEnD,GAAS,EAC1C,OAAOA,EACLpC,QAAS,IAAIgE,OAAQ3C,EAA8B,KAAO,IAC1DrB,QAAS,IAAIgE,OAAQ5C,EAAgB,KAAO,MCFxC,SAASoE,EAAT,GAA6D,IAAtC,MAAEpF,EAAF,KAASgC,GAA6B,EAArBjC,EAAqB,uDAARC,EACvDV,EAAQS,EAEZ,KAAQT,KACP,GAAK0C,EAAM1C,KAAY0B,EACtB,OAAO1B,ECRH,SAAS+F,EAAoBjL,GACnC,MAAM,aAAEmI,EAAF,MAAgBvC,GAAU5F,EAE1BkL,EAAc/C,EADF6C,EAAchL,EAAO4F,IAGvC,OAASsF,GAAeA,EAAYjK,OAAS,ECHvC,SAASkK,EAAkBnL,EAAOM,EAAM8K,GAC9C,MAAM,aAAEjD,EAAF,MAAgBvC,GAAU5F,EAE1BkL,EAAc/C,EADF6C,EAAchL,EAAO4F,IAGvC,OAAOsF,GAAsC,IAAvBA,EAAYjK,OAIfiK,EAAaA,EAAYjK,OAAS,GAEnCX,OAASA,EALnBA,IAAS8K,ECXX,SAASC,EAAT,GAAuC,IAAjB,MAAEzF,EAAF,IAASE,GAAQ,EAC7C,QAAeiD,IAAVnD,QAA+BmD,IAARjD,EAI5B,OAAOF,IAAUE,ECHX,SAASwF,EAAT,GAA6B,IAAX,KAAE1D,GAAS,EACnC,OAAuB,IAAhBA,EAAK3G,OAWN,SAASsK,EAAT,GAA6C,IAAvB,KAAE3D,EAAF,MAAQhC,EAAR,IAAeE,GAAQ,EACnD,OAAKF,IAAUE,IAIM,IAAhB8B,EAAK3G,QAIK,IAAV2E,GAAegC,EAAK7C,MAAO,EAAG,KAAQ6B,GAItChB,IAAUgC,EAAK3G,QAAU2G,EAAK7C,OAAQ,KAAQ6B,GAKlDgB,EAAK7C,MAAOa,EAAQ,EAAGE,EAAM,KAC5B,GAAGc,IAAmBA,KC3BlB,SAAS4E,EAAMxI,GAAyB,IAAjByI,EAAiB,uDAAL,GAKzC,MAJ0B,iBAAdA,IACXA,EAAY/D,EAAQ,CAAEE,KAAM6D,KAGtB7G,EACN5B,EAAOwH,QAAQ,CAAEkB,EAAF,SAAc,QAAE5G,EAAF,aAAWqD,EAAX,KAAyBP,GAAvC,QAAqD,CACnE9C,QAAS4G,EAAW5G,QAAQyF,OAAQkB,EAAU3G,QAASA,GACvDqD,aAAcuD,EAAWvD,aAAaoC,OACrCkB,EAAUtD,aACVA,GAEDP,KAAM8D,EAAW9D,KAAO6D,EAAU7D,KAAOA,OCArC,SAAS+D,EAAoBzI,EAAM0I,GAMzC,GAA8B,iBAL9BA,EAAW,CACV1I,KAAAA,KACG0I,IAGiB1I,KAKrB,GAAO,qCAAqCoH,KAAMsB,EAAS1I,MAO3D,IAAK+D,EAAAA,EAAAA,QAAQC,GAAgBjE,cAAe2I,EAAS1I,MACpDjD,OAAO4L,QAAQC,MACd,WAAaF,EAAS1I,KAAO,iCAK/B,GAAiC,iBAArB0I,EAASrI,SAA6C,KAArBqI,EAASrI,QAKtD,GACiC,iBAAvBqI,EAAStI,WACM,KAAvBsI,EAAStI,WACa,OAAvBsI,EAAStI,UAQV,GAAO,4BAA4BgH,KAAMsB,EAAStI,WAAlD,CAOA,GAA4B,OAAvBsI,EAAStI,UAAqB,CAClC,MAAMyI,GAA2B9E,EAAAA,EAAAA,QAChCC,GACC/D,4BAA6ByI,EAASrI,SAExC,GAAKwI,EAIJ,YAHA9L,OAAO4L,QAAQC,MACb,WAAWC,EAAyB7I,wDAA0D0I,EAASrI,iBAIpG,CACN,MAAMyI,GAAyB/E,EAAAA,EAAAA,QAC9BC,GACC1D,0BAA2BoI,EAAStI,WAEtC,GAAK0I,EAIJ,YAHA/L,OAAO4L,QAAQC,MACb,WAAWE,EAAuB9I,qDAAuD0I,EAAStI,eAMtG,GAAS,UAAWsI,GAAiC,KAAnBA,EAASK,MAO3C,GAAK,aAAcL,GAAYA,EAASM,SAASjL,OAAS,EACzDhB,OAAO4L,QAAQC,MACd,eACCF,EAAS1I,KACT,2CAJH,CASA,GAA+B,iBAAnB0I,EAASK,MAOrB,OAFAE,EAAAA,EAAAA,UAAUjF,GAAgBvD,eAAgBiI,GAEnCA,EANN3L,OAAO4L,QAAQC,MAAO,uCAhBtB7L,OAAO4L,QAAQC,MACd,eAAiBF,EAAS1I,KAAO,6BAhClCjD,OAAO4L,QAAQC,MACd,uGARD7L,OAAO4L,QAAQC,MACd,8EAVD7L,OAAO4L,QAAQC,MAAO,2CAdtB7L,OAAO4L,QAAQC,MACd,6KAND7L,OAAO4L,QAAQC,MAAO,iCCZjB,SAASM,EACfpM,EACA+G,GAGC,IAFDpB,EAEC,uDAFY3F,EAAM4F,MACnBC,EACC,uDADU7F,EAAM8F,IAEjB,MAAM,QAAEhB,EAAF,cAAWiB,GAAkB/F,EAC7B6E,EAAaC,EAAQC,QAI3B,GAAKY,IAAeE,EAAW,CAC9B,MAAMR,GAAShC,EAAAA,EAAAA,MAAMwB,EAAYc,GAAc,CAAErF,KAAMyG,IAEvD,GAAK1B,EAAS,CACb,MAAQhC,EAAAA,EAAAA,MAAMwB,EAAYc,GAAcN,IACvCgH,EAAexH,EAAYc,EAAYoB,GACvCpB,IAKD,IAFAE,KAEQxC,EAAAA,EAAAA,MAAMwB,EAAYgB,GAAYR,IACrCgH,EAAexH,EAAYgB,EAAUkB,GACrClB,UAIF,IAAM,IAAI7E,EAAI2E,EAAY3E,EAAI6E,EAAU7E,IAClC6D,EAAY7D,IAChBqL,EAAexH,EAAY7D,EAAG+F,GAKjC,OAAOnC,EAAkB,IACrB5E,EACH8E,QAASD,EACTkB,eAAeK,EAAAA,EAAAA,QAAQL,EAAe,CAAEzF,KAAMyG,MAIhD,SAASsF,EAAevH,EAASI,EAAO6B,GACvC,MAAMlC,EAAaC,EAASI,GAAQgB,QACnC,QAAE,KAAE5F,GAAJ,SAAgBA,IAASyG,KAGrBlC,EAAW5D,OACf6D,EAASI,GAAUL,SAEZC,EAASI,GCtDX,SAASoH,EACftM,EACAuM,GAGC,IAFD5G,EAEC,uDAFY3F,EAAM4F,MACnBC,EACC,uDADU7F,EAAM8F,IAEjB,MAAM,QAAEhB,EAAF,aAAWqD,EAAX,KAAyBP,GAAS5H,EAEV,iBAAlBuM,IACXA,EAAgB7E,EAAQ,CAAEE,KAAM2E,KAGjC,MAAMrH,EAAQS,EAAa4G,EAAc3E,KAAK3G,OAE9C,OAAO2D,EAAkB,CACxBE,QAASA,EACPC,MAAO,EAAGY,GACV4E,OAAQgC,EAAczH,QAASA,EAAQC,MAAOc,IAChDsC,aAAcA,EACZpD,MAAO,EAAGY,GACV4E,OACAgC,EAAcpE,aACdA,EAAapD,MAAOc,IAEtB+B,KACCA,EAAK7C,MAAO,EAAGY,GACf4G,EAAc3E,KACdA,EAAK7C,MAAOc,GACbD,MAAOV,EACPY,IAAKZ,IChCA,SAASsH,EAAQxM,EAAO2F,EAAYE,GAC1C,OAAOyG,EAAQtM,EAAO0H,IAAU/B,EAAYE,GCItC,SAASL,EAAT,EAENiH,EACAvB,GACC,IAHD,QAAEpG,EAAF,aAAWqD,EAAX,KAAyBP,EAAzB,MAA+BhC,EAA/B,IAAsCE,GAGrC,EAyCD,OAxCA8B,EAAOA,EAAKpC,QAASiH,GAAS,SAAEC,GAAoB,2BAAVC,EAAU,iCAAVA,EAAU,kBACnD,MAAMC,EAASD,EAAMA,EAAK1L,OAAS,GACnC,IACI4D,EACAgI,EAFAC,EAAU5B,EAmCd,MA/BwB,mBAAZ4B,IACXA,EAAU5B,EAAawB,KAAUC,IAGV,iBAAZG,GACXjI,EAAaiI,EAAQhI,QACrB+H,EAAkBC,EAAQ3E,aAC1B2E,EAAUA,EAAQlF,OAElB/C,EAAapC,MAAOqK,EAAQ7L,QAC5B4L,EAAkBpK,MAAOqK,EAAQ7L,QAE5B6D,EAAS8H,KACb/H,EAAaA,EAAWkI,KAAMjI,EAAS8H,MAIzC9H,EAAUA,EACRC,MAAO,EAAG6H,GACVrC,OAAQ1F,EAAYC,EAAQC,MAAO6H,EAASF,EAAMzL,SACpDkH,EAAeA,EACbpD,MAAO,EAAG6H,GACVrC,OACAsC,EACA1E,EAAapD,MAAO6H,EAASF,EAAMzL,SAGhC2E,IACJA,EAAQE,EAAM8G,EAASE,EAAQ7L,QAGzB6L,KAGDlI,EAAkB,CAAEE,QAAAA,EAASqD,aAAAA,EAAcP,KAAAA,EAAMhC,MAAAA,EAAOE,IAAAA,ICjDzD,SAASkH,EACfhN,GAGC,IAFD2F,EAEC,uDAFY3F,EAAM4F,MACnBC,EACC,uDADU7F,EAAM8F,IAEjB,MAAMmH,EAAajN,EAAM4H,KAAK7C,MAAO,EAAGY,GAClCuH,EAA6BD,EAAWE,YAAavG,GACrDwG,EACLpN,EAAMmI,aAAc+E,GACrB,IAAI/E,EAAe,CAAC,GAEfiF,IACJjF,EAAe,CAAEiF,IAGlB,MAAMb,EAAgB,CACrBzH,QAAS,CAAC,GACVqD,aAAAA,EACAP,KAAMhB,GAGP,OAAO0F,EAAQtM,EAAOuM,EAAe5G,EAAYE,GClB3C,SAASwH,EAAqBrN,GAAyB,IAAlBsN,IAAkB,yDAC7D,MAAM,aAAEnF,EAAF,KAAgBP,EAAhB,MAAsBhC,EAAtB,IAA6BE,GAAQ9F,EACrCuN,EAAYlC,EAAarL,GAC/B,IAaIwN,EAbAtI,EAAQU,EAAQ,EAChB6H,EAAcF,EAAY3H,EAAQ,EAAIA,EACtC8H,EAAY5H,EAOhB,GANOwH,IACNpI,EAAQY,EACR2H,EAAc7H,EACd8H,EAAYH,EAAYzH,EAAM,EAAIA,GAG9B8B,EAAM1C,KAAY0B,EAAvB,CAOA,GAAK2G,GAAapF,EAAcjD,IAAWiD,EAAcjD,GAAQjE,OAAS,CACzE,MAAM4L,EAAkB1E,EAAapD,QAErC8H,EAAiB3H,GAAUiD,EAAcjD,GAAQH,MAAO,GAAI,GAC5DyI,EAAW,IACPxN,EACHmI,aAAc0E,QAGfW,EAAWhB,EAAQxM,EAAOyN,EAAaC,GAExC,OAAOF,GC/BD,SAASG,GAAc3N,EAAO4N,EAAgBjI,EAAYE,GAOhE,OAAOyG,EAAQtM,EANO,CACrB8E,QAAS,CAAC,GACVqD,aAAc,CAAEyF,GAChBhG,KAAMf,GAG8BlB,EAAYE,GChB3C,SAASd,GAAO/E,GAAwD,IAAjD2F,EAAiD,uDAApC3F,EAAM4F,MAAOC,EAAuB,uDAAZ7F,EAAM8F,IACxE,MAAM,QAAEhB,EAAF,aAAWqD,EAAX,KAAyBP,GAAS5H,EAExC,YAAoB+I,IAAfpD,QAAyCoD,IAAblD,EACzB,IAAK7F,GAGN,CACN8E,QAASA,EAAQC,MAAOY,EAAYE,GACpCsC,aAAcA,EAAapD,MAAOY,EAAYE,GAC9C+B,KAAMA,EAAK7C,MAAOY,EAAYE,ICLzB,SAASgI,GAAT,EAA6DvE,GAAS,IAAtD,QAAExE,EAAF,aAAWqD,EAAX,KAAyBP,EAAzB,MAA+BhC,EAA/B,IAAsCE,GAAgB,EAC5E,GAAuB,iBAAXwD,EACX,OAAOwE,MAAqBtL,WAG7B,IAAIuL,EAAY,EAEhB,OAAOnG,EAAKiG,MAAOvE,GAAS5H,KAAOsM,IAClC,MAAMrI,EAAaoI,EACb/N,EAAQ,CACb8E,QAASA,EAAQC,MAAOY,EAAYA,EAAaqI,EAAU/M,QAC3DkH,aAAcA,EAAapD,MAC1BY,EACAA,EAAaqI,EAAU/M,QAExB2G,KAAMoG,GAmBP,OAhBAD,GAAazE,EAAOrI,OAAS+M,EAAU/M,YAExB8H,IAAVnD,QAA+BmD,IAARjD,IACtBF,GAASD,GAAcC,EAAQmI,EACnC/N,EAAM4F,MAAQA,EAAQD,EACXC,EAAQD,GAAcG,EAAMH,IACvC3F,EAAM4F,MAAQ,GAGVE,GAAOH,GAAcG,EAAMiI,EAC/B/N,EAAM8F,IAAMA,EAAMH,EACPC,EAAQmI,GAAajI,EAAMiI,IACtC/N,EAAM8F,IAAMkI,EAAU/M,SAIjBjB,KAIT,SAAS8N,GAAT,GAIE,IAHD,QAAEhJ,EAAF,aAAWqD,EAAX,KAAyBP,EAAzB,MAA+BhC,EAA/B,IAAsCE,GAGrC,EAFDH,EAEC,uDAFYC,EACbC,EACC,uDADUC,EAEX,QAAeiD,IAAVnD,QAA+BmD,IAARjD,EAC3B,OAGD,MAAMmI,EAAS,CACdnJ,QAASA,EAAQC,MAAO,EAAGY,GAC3BwC,aAAcA,EAAapD,MAAO,EAAGY,GACrCiC,KAAMA,EAAK7C,MAAO,EAAGY,IAEhBuI,EAAQ,CACbpJ,QAASA,EAAQC,MAAOc,GACxBsC,aAAcA,EAAapD,MAAOc,GAClC+B,KAAMA,EAAK7C,MAAOc,GAClBD,MAAO,EACPE,IAAK,GAGN,MAAO,CAENN,EAASyI,EAAQ,WAAY,IAC7BzI,EAAS0I,EAAO,WAAY,KCrE9B,SAASC,GAAqB5J,EAAY0D,GACzC,GAAKA,EACJ,OAAO1D,EAGR,MAAM6J,EAAgB,GAEtB,IAAM,MAAMjP,KAAOoF,EAAa,CAC/B,IAAI8J,EAASlP,EACRA,EAAImP,WAAY,6BACpBD,EAASlP,EAAI4F,MAAO,0BAA0B9D,SAG/CmN,EAAeC,GAAW9J,EAAYpF,GAGvC,OAAOiP,EAoBR,SAASG,GAAT,GAOI,IAPiB,KACpBjO,EADoB,WAEpBiE,EAFoB,uBAGpBgD,EAHoB,OAIpBiH,EAJoB,cAKpBC,EALoB,eAMpBxG,GACG,EACH,MAAMlB,GCtCwB7D,EDsCI5C,GCrC3B2G,EAAAA,EAAAA,QAAQC,GAAgBjE,cAAeC,IADxC,IAAwBA,EDwC9B,IAAIwL,EAAoB,GAMxB,GAJKD,IACJC,EAAmB,kCAAqC,SAGlD3H,EAKN,OAJKxC,IACJmK,EAAoB,IAAKnK,KAAemK,IAGlC,CACNpO,KAAAA,EACAiE,WAAY4J,GACXO,EACAzG,GAEDuG,OAAAA,GAIFE,EAAoB,IAAKnH,KAA2BmH,GAEpD,IAAM,MAAMxL,KAAQqB,EAAa,CAChC,MAAMpF,IAAM4H,EAAWxC,YACpBwC,EAAWxC,WAAYrB,GAGrB/D,EACJuP,EAAmBvP,GAAQoF,EAAYrB,GAEvCwL,EAAmBxL,GAASqB,EAAYrB,GAY1C,OARK6D,EAAWzD,YACVoL,EAAkB1H,MACtB0H,EAAkB1H,MAAS,GAAGD,EAAWzD,aAAeoL,EAAkB1H,QAE1E0H,EAAkB1H,MAAQD,EAAWzD,WAIhC,CACNhD,KAAMyG,EAAWxD,QACjBiL,OAAQzH,EAAWyH,OACnBjK,WAAY4J,GAAqBO,EAAmBzG,IAWtD,SAAS0G,GAAc9N,EAAGC,EAAGoE,GAC5B,GACC,GAAKrE,EAAGqE,KAAYpE,EAAGoE,GACtB,OAAO,QAECA,KAEV,OAAO,EAGD,SAAS0J,GAAT,GAgBH,IAhBoB,MACvB5O,EADuB,aAEvB8H,EAFuB,mBAGvBI,EAHuB,YAIvB2G,EAJuB,OAKvBC,EALuB,aAMvBC,EANuB,UAOvBC,EAPuB,OAQvBC,EARuB,QASvBC,EATuB,OAUvB1C,EAVuB,WAWvB2C,EAXuB,aAYvBC,EAZuB,WAavBC,EAbuB,eAcvBpH,EAduB,YAevBqH,GACG,EACH,MAAM,QAAExK,EAAF,aAAWqD,EAAX,KAAyBP,EAAzB,MAA+BhC,EAA/B,IAAsCE,GAAQ9F,EAC9CuP,EAAgBzK,EAAQ7D,OAAS,EACjCuO,EAAOX,IACPY,EAAkB,CAAEnP,KAAMwH,GAC1B/B,EAAgB0E,EAAkBzK,GAClC0P,EAAsB3J,EAAeA,EAAc9E,OAAS,GAElE,IAAI0O,EACAC,EACAC,EAGC/H,GACJgH,EAAQA,EAAQU,EAAM,CAAElP,KAAMwH,IAAkB,IAChD8H,EAAuBD,EAAuB,CAAEF,IAEhDX,EAAQU,EAAM,IAGf,IAAM,IAAIxO,EAAI,EAAGA,EAAIuO,EAAevO,IAAM,CACzC,MAAM8O,EAAYlI,EAAKmI,OAAQ/O,GACzBgP,EACL/H,KAEI4H,GACHA,IAAkBjJ,GAGA,OAAlBiJ,GAEF,IAAII,EAAmBnL,EAAS9D,GAG3B8G,IAEHmI,EADIH,IAAclJ,EACC+I,GAClBxH,EAAcnH,IAAO,IACpBwJ,QACD,CAAEhC,EAAanD,KACdmD,EAAY0H,KAAM7K,EAAQoK,GACnBjH,IAER,CAAEiH,IAGgB,IACfE,KACEM,GAAoB,KAK5B,IAAIE,EAAUpB,EAAcS,GAE5B,GAAKQ,GAAuBF,IAAclJ,EAAiB,CAC1D,IAAIvE,EAAO8N,EAEX,MAAUlB,EAAQ5M,IACjBA,EAAO0M,EAAc1M,GAGtByM,EAAQE,EAAW3M,GvB7LA,UuBiMpB,GAAKwN,IAAkBjJ,EAAiB,CACvC,IAAIvE,EAAO8N,EAEX,MAAUlB,EAAQ5M,IACjBA,EAAO0M,EAAc1M,GAGjB+M,GAAgBxJ,IAAU5E,GAC9BoO,EAAcI,EAAMnN,GAGhBgN,GAAcvJ,IAAQ9E,GAC1BqO,EAAYG,EAAMnN,GAqE8B,MAjBlD,GAhDK4N,GACJA,EAAiBjL,SAAS,CAAEK,EAAQC,KACnC,GACC6K,GACAP,GAEAjB,GACCsB,EACAL,EACAtK,KAICwK,IAAclJ,GACfqJ,EAAiBhP,OAAS,IAAMqE,GAGjC,YADA6K,EAAUpB,EAAcoB,IAIzB,MAAM,KAAE7P,EAAF,WAAQiE,EAAR,uBAAoBgD,GAA2BlC,EAE/CoJ,EACLxG,GACA6H,IAAclJ,GACdvB,IAAWqK,EAENU,EAASpB,EAAWmB,GACpBE,EAAUvB,EACfsB,EACA7B,GAAY,CACXjO,KAAAA,EACAiE,WAAAA,EACAgD,uBAAAA,EACAkH,cAAAA,EACAxG,eAAAA,KAIGgH,EAAQkB,IAA2C,IAA9BjB,EAASiB,GAAUlP,QAC5CuL,EAAQ2D,GAGTA,EAAUrB,EAAQuB,EAAS,OAKxBP,IAAclJ,EAOR,IAAN5F,IACCoO,GAA0B,IAAVxJ,GACpBwJ,EAAcI,EAAMW,GAGhBd,GAAsB,IAARvJ,GAClBuJ,EAAYG,EAAMW,IAIfL,IAAcjJ,GACXoB,GAA8C,YAA5B,UAAAE,EAAcnH,UAAd,eAAmBV,MAc3C6P,EAAUrB,EACTE,EAAWmB,GACX5B,GAAY,IACRpG,EAAcnH,GACjBwN,QAAQ,EACRvG,eAAAA,MAlBFkI,EAAUrB,EACTE,EAAWmB,GACX5B,GAAY,CACXjO,KAAM,SACN2H,eAAAA,KAGF6G,EAAQqB,EAAS,CAChB7J,KAAMgK,mBACLnI,EAAcnH,GAAIuD,WAAY,6BAcjC4L,EAAUrB,EAAQE,EAAWmB,GAAW,KAC3BjI,GAAoC,OAAd4H,EAYtBb,EAAQkB,GAGrBhB,EAAYgB,EAASL,GAFrBK,EAAUrB,EAAQE,EAAWmB,GAAWL,IAZxCK,EAAUrB,EAAQE,EAAWmB,GAAW,CACvC7P,KAAM,KACNiE,WAAY0D,EACT,CACA,4BAA6B,aAE7Bc,EACHyF,QAAQ,IAGT2B,EAAUrB,EAAQE,EAAWmB,GAAW,KAOpCf,GAAgBxJ,IAAU5E,EAAI,GAClCoO,EAAcI,EAAMW,GAGhBd,GAAcvJ,IAAQ9E,EAAI,GAC9BqO,EAAYG,EAAMW,GAGdH,GAAuBhP,IAAM4G,EAAK3G,SACtC6N,EAAQE,EAAWmB,GvBvUA,UuByUdb,GAA+B,IAAhB1H,EAAK3G,QACxB6N,EAAQE,EAAWmB,GAAW,CAC7B7P,KAAM,OACNiE,WAAY,CACX,6BAA8B+K,EAI9BiB,gBAAiB,QACjBC,MAAO,gHAMXZ,EAAuBK,EACvBJ,EAAgBC,OAvFfF,EAAuBK,EACvBJ,EAAgBC,EAyFlB,OAAON,EEvVR,SAASiB,GAAkBpO,EAAMqO,EAAUC,GAC1C,MAAMlI,EAAapG,EAAKoG,WACxB,IAAIzH,EAAI,EAER,KAAUqB,EAAOA,EAAKuO,iBACrB5P,IASD,OANA2P,EAAO,CAAE3P,KAAM2P,GAEVlI,IAAeiI,IACnBC,EAAOF,GAAkBhI,EAAYiI,EAAUC,IAGzCA,EAWR,SAASE,GAAexO,EAAMsO,GAG7B,IAFAA,EAAO,IAAKA,GAEJtO,GAAQsO,EAAK1P,OAAS,GAC7BoB,EAAOA,EAAK6G,WAAYyH,EAAKG,SAG9B,MAAO,CACNzO,KAAAA,EACAuK,OAAQ+D,EAAM,IAIhB,SAAS7B,GAAQnH,EAASoJ,GACH,iBAAVA,IACXA,EAAQpJ,EAAQqJ,cAAcC,eAAgBF,IAG/C,MAAM,KAAEzQ,EAAF,WAAQiE,GAAewM,EAE7B,GAAKzQ,EAAO,CACXyQ,EAAQpJ,EAAQqJ,cAAc3K,cAAe/F,GAE7C,IAAM,MAAMnB,KAAOoF,EAClBwM,EAAMG,aAAc/R,EAAKoF,EAAYpF,IAIvC,OAAOwI,EAAQwJ,YAAaJ,GAG7B,SAAS5B,GAAY9M,EAAMuF,GAC1BvF,EAAK+O,WAAYxJ,GAGlB,SAASmH,GAAT,GAAuC,IAAhB,UAAEsC,GAAc,EACtC,OAAOA,EAGR,SAASrC,GAAT,GAAqC,IAAjB,WAAEvG,GAAe,EACpC,OAAOA,EAGR,SAASwG,GAAQ5M,GAChB,OAAOA,EAAK2G,WAAa3G,EAAK4G,UAG/B,SAASiG,GAAT,GAAkC,IAAhB,UAAE9F,GAAc,EACjC,OAAOA,EAGR,SAASoD,GAAQnK,GAChB,OAAOA,EAAKoG,WAAW6I,YAAajP,GAG9B,SAASkP,GAAT,GAOH,IAPmB,MACtBvR,EADsB,aAEtB8H,EAFsB,oBAGtB0J,EAHsB,eAItBvJ,GAAiB,EAJK,YAKtBqH,EALsB,IAMtBmC,EAAMrJ,UACH,EACCsJ,EAAY,GACZC,EAAU,GA8Cd,OA5CKH,IACJxR,EAAQ,IACJA,EACH8E,QAAS0M,EAAqBxR,KAyCzB,CACNwG,KA1BYoI,GAAQ,CACpB5O,MAAAA,EACA8H,aAAAA,EACA+G,YALmB,IAAMxI,EAAeoL,EAAK,IAM7C3C,OAAAA,GACAC,aAAAA,GACAC,UAAAA,GACAC,OAAAA,GACAC,QAAAA,GACA1C,OAToB,GAUpB2C,WAAAA,GACAC,aAAc5I,EAAM2J,GACnBuB,EAAYjB,GAAkBN,EAAS3J,EAAM,CAC5C2J,EAAQ/G,UAAUnI,UAGpBoO,WAAY7I,EAAM2J,GACjBwB,EAAUlB,GAAkBN,EAAS3J,EAAM,CAC1C2J,EAAQ/G,UAAUnI,UAGpBgH,eAAAA,EACAqH,YAAAA,IAKAsC,UAAW,CAAEF,UAAAA,EAAWC,QAAAA,IAiBnB,SAASjP,GAAT,GAOH,IAPmB,MACtB1C,EADsB,QAEtB6R,EAFsB,aAGtB/J,EAHsB,oBAItB0J,EAJsB,kBAKtBM,EALsB,YAMtBxC,GACG,EAEH,MAAM,KAAE9I,EAAF,UAAQoL,GAAcL,GAAO,CAClCvR,MAAAA,EACA8H,aAAAA,EACA0J,oBAAAA,EACAlC,YAAAA,EACAmC,IAAKI,EAAQb,gBAGde,GAAYvL,EAAMqL,QAEG9I,IAAhB/I,EAAM4F,OAAyBkM,GAmF9B,WAAiDD,GAAU,IAAlC,UAAEH,EAAF,QAAaC,GAAqB,EACjE,MAAQtP,KAAMqG,EAAgBkE,OAAQjE,GAAgBkI,GACrDgB,EACAH,IAEOrP,KAAMuG,EAAcgE,OAAQ/D,GAAcgI,GACjDgB,EACAF,IAEK,cAAEX,GAAkBa,GACpB,YAAEG,GAAgBhB,EAClBY,EAAYI,EAAYC,eACxBpK,EAAQmJ,EAAckB,cAE5BrK,EAAMsK,SAAUzJ,EAAgBC,GAChCd,EAAMuK,OAAQxJ,EAAcC,GAE5B,MAAM,cAAEwJ,GAAkBrB,EAE1B,GAAKY,EAAUU,WAAa,EAAI,CAG/B,GA/BqBzR,EA+BFgH,EA/BK/G,EA+BE8Q,EAAUW,WAAY,GA7BhD1R,EAAE6H,iBAAmB5H,EAAE4H,gBACvB7H,EAAE8H,cAAgB7H,EAAE6H,aACpB9H,EAAE+H,eAAiB9H,EAAE8H,cACrB/H,EAAEgI,YAAc/H,EAAE+H,UA2BjB,OAGD+I,EAAUY,kBAnCZ,IAAuB3R,EAAGC,EAsCzB8Q,EAAUa,SAAU5K,GAKfwK,IAAkBrB,EAAcqB,eAM/BA,aAAyBL,EAAYU,aACzCL,EAAcM,QA3HfC,CAAgBhB,EAAWC,GAItB,SAASE,GAAYc,EAAQhB,GACnC,IACIiB,EADA9R,EAAI,EAGR,KAAU8R,EAAcD,EAAOE,YAAe,CAC7C,MAAMC,EAAenB,EAAQ3I,WAAYlI,GAEzC,GAAOgS,EAEA,GAAOA,EAAaC,YAAaH,GAuCvCD,EAAOvB,YAAawB,QAtCpB,GACCE,EAAarJ,WAAamJ,EAAYnJ,UACpCqJ,EAAahK,WAAagK,EAAa/J,WACxC+J,EAAaE,OAASJ,EAAYI,KAEnCrB,EAAQsB,aAAcL,EAAaE,OAC7B,CACN,MAAMI,EAAoBJ,EAAazO,WACjC8O,EAAmBP,EAAYvO,WAErC,GAAK6O,EAAoB,CACxB,IAAIE,EAAKF,EAAkBnS,OAI3B,KAAQqS,KAAO,CACd,MAAM,KAAEpQ,GAASkQ,EAAmBE,GAE7BR,EAAYhJ,aAAc5G,IAChC8P,EAAaO,gBAAiBrQ,IAKjC,GAAKmQ,EACJ,IAAM,IAAIC,EAAK,EAAGA,EAAKD,EAAiBpS,OAAQqS,IAAO,CACtD,MAAM,KAAEpQ,EAAF,MAAQlD,GAAUqT,EAAkBC,GAErCN,EAAalJ,aAAc5G,KAAWlD,GAC1CgT,EAAa9B,aAAchO,EAAMlD,GAKpC+R,GAAYe,EAAaE,GACzBH,EAAOvB,YAAawB,QArCrBjB,EAAQV,YAAa2B,GA2CtB9R,IAGD,KAAQ6Q,EAAQ3I,WAAYlI,IAC3B6Q,EAAQP,YAAaO,EAAQ3I,WAAYlI,IC5P3C,MAAM,GAA+Bf,OAAW,GAAc,WC8BvD,SAASuT,GAAT,GAAqE,IAA9C,MAAExT,EAAF,aAAS8H,EAAT,mBAAuBI,GAAuB,EAe3E,OAAOuL,GAdM7E,GAAQ,CACpB5O,MAAAA,EACA8H,aAAAA,EACAI,mBAAAA,EACA2G,YAAAA,GACAC,OALoB,GAMpBC,aANoB,GAOpBC,UAPoB,GAQpBC,OARoB,GASpBC,QAToB,GAUpB1C,OAVoB,GAWpB2C,WAAUA,KAGqB/E,UAGjC,SAASyE,KACR,MAAO,GAGR,SAASE,GAAT,GAAsC,IAAf,SAAE3E,GAAa,EACrC,OAAOA,GAAYA,EAAUA,EAASnJ,OAAS,GAGhD,SAAS6N,GAAQsB,EAAQ5B,GAQxB,MAPuB,iBAAXA,IACXA,EAAS,CAAE5G,KAAM4G,IAGlBA,EAAO4B,OAASA,EAChBA,EAAOhG,SAAWgG,EAAOhG,UAAY,GACrCgG,EAAOhG,SAAS8F,KAAM1B,GACfA,EAGR,SAASW,GAAYX,EAAQ5G,GAC5B4G,EAAO5G,MAAQA,EAGhB,SAASoH,GAAT,GAAiC,IAAb,OAAEoB,GAAW,EAChC,OAAOA,EAGR,SAASnB,GAAT,GAA4B,IAAX,KAAErH,GAAS,EAC3B,MAAuB,iBAATA,EAGf,SAASsH,GAAT,GAA6B,IAAX,KAAEtH,GAAS,EAC5B,OAAOA,EAGR,SAAS4E,GAAQgC,GAChB,MAAMtJ,EAAQsJ,EAAO4B,OAAOhG,SAAS1G,QAAS8K,GAM9C,OAJgB,IAAXtJ,GACJsJ,EAAO4B,OAAOhG,SAASjE,OAAQjB,EAAO,GAGhCsJ,EAGR,SAASkF,GAAT,GAAqE,IAAzC,KAAEpT,EAAF,WAAQiE,EAAR,OAAoBiK,EAApB,SAA4BpE,GAAa,EAChEuJ,EAAkB,GAEtB,IAAM,MAAMxU,KAAOoF,GACXqP,EAAAA,GAAAA,sBAAsBzU,KAI7BwU,GAAoB,IAAIxU,OAAU0U,EAAAA,GAAAA,iBACjCtP,EAAYpF,QAId,OAAKqP,EACI,IAAIlO,IAASqT,KAGd,IAAIrT,IAASqT,KAAqBF,GACzCrJ,OACO9J,KAGT,SAASmT,KAAoC,IAAhBrJ,EAAgB,uDAAL,GACvC,OAAOA,EACL1I,KAAOqP,QACahI,IAAfgI,EAAMzK,KACHyK,EAAMzK,UAGQyC,IAAfgI,EAAMnJ,KACV8L,GAAmB3C,IACnB+C,EAAAA,GAAAA,oBAAoB/C,EAAMnJ,QAE7B4D,KAAM,IC9HT,MAAM,GAA+BvL,OAAW,GAAQ,KCAlD,GAA+BA,OAAW,GAAQ,KC0BjD,SAAS8T,GAAc/T,EAAOqF,GACpC,OAAKwF,EAAiB7K,EAAOqF,EAAO/E,OAE9B+E,EAAO4G;;CAEX+H,EAAAA,GAAAA,QAAOC,EAAAA,GAAAA,UAASC,EAAAA,GAAAA,IAAI,eAAiB7O,EAAO4G,OAAS,aAE/CG,EAAcpM,EAAOqF,EAAO/E,QAG/B+E,EAAO4G;;CAEX+H,EAAAA,GAAAA,QAAOC,EAAAA,GAAAA,UAASC,EAAAA,GAAAA,IAAI,eAAiB7O,EAAO4G,OAAS,aAE/CvG,EAAa1F,EAAOqF,ICnBrB,SAAS8O,GAAsBjR,GACrC,MAAMkR,GAAYnN,EAAAA,EAAAA,QAAQC,GAAgBjE,cAAeC,GAEzD,GAAOkR,EAOP,OAFAjI,EAAAA,EAAAA,UAAUjF,GAAgBrD,kBAAmBX,GAEtCkR,EANNnU,OAAO4L,QAAQC,MAAQ,UAAU5I,wBCX5B,SAASmR,GAAoBrU,GACnC,MAAMsU,EAAYtJ,EAAchL,GAGhC,QAAmB+I,IAAduL,EACJ,OAAO,EAGR,MAAM,aAAEnM,GAAiBnI,EACnBuU,EAAoBvJ,EAAchL,EAAOsU,GACzCE,EAAqBrM,EAAcmM,IAAe,GAClDG,EAA6BtM,EAAcoM,IAAuB,GAIxE,OAAOC,EAAmBvT,QAAUwT,EAA2BxT,OCdzD,SAASyT,GAAqB1U,GACpC,MAAM,aAAEmI,EAAF,MAAgBvC,GAAU5F,EAEhC,YAA6C+I,IAAtCZ,EADmB6C,EAAchL,EAAO4F,ICiCzC,SAAS+O,GAAiB3U,EAAO4U,GACvC,IAAOP,GAAoBrU,GAC1B,OAAOA,EAGR,MAAMsU,EAAYtJ,EAAchL,GAC1BuU,EAAoBvJ,EAAchL,EAAOsU,IACzC,KAAE1M,EAAF,aAAQO,EAAR,IAAsBrC,GAAQ9F,EAC9B6E,EAAasD,EAAapD,QAC1B8P,EAvCP,WAA0DP,GAAY,IAApC,KAAE1M,EAAF,aAAQO,GAA4B,EACrE,MAAM2M,EAAe3M,EAAcmM,IAAe,GAElD,IAAIpP,EAAQoP,EAEZ,KAAQpP,MAAW,GAAI,CACtB,GAAK0C,EAAM1C,KAAY0B,EACtB,SAGD,MAAM3B,EAAiBkD,EAAcjD,IAAW,GAIhD,GAAKD,EAAehE,SAAW6T,EAAa7T,OAAS,EACpD,OAAOiE,EACD,GAAKD,EAAehE,QAAU6T,EAAa7T,OACjD,QAsB2B8T,CAAyB/U,EAAOsU,GAE7D,IAAM,IAAIpP,EAAQoP,EAAWpP,EAAQY,EAAKZ,IACzC,GAAK0C,EAAM1C,KAAY0B,EAMvB,GAAKiO,EAAuB,CAC3B,MAAMG,EAAgB7M,EAAc0M,IAA0B,GAC9DhQ,EAAYK,GAAU8P,EAAczK,QACjC1F,EAAYK,IAAW,IAAKH,MAAOiQ,EAAc/T,OAAS,QAEvD,CACN,MAAM+T,EAAgB7M,EAAcoM,IAAuB,GACrDU,EACLD,EAAeA,EAAc/T,OAAS,IAAO2T,EAE9C/P,EAAYK,GAAU8P,EAAczK,OACnC,CAAE0K,IACApQ,EAAYK,IAAW,IAAKH,MAAOiQ,EAAc/T,SAKtD,MAAO,IACHjB,EACHmI,aAActD,GCrET,SAASqQ,GAAT,EAAqDZ,GAAY,IAApC,KAAE1M,EAAF,aAAQO,GAA4B,EACvE,MAAM2M,EAAe3M,EAAcmM,IAAe,GAElD,IAAIpP,EAAQoP,EAEZ,KAAQpP,MAAW,GAClB,GAAK0C,EAAM1C,KAAY0B,IAIAuB,EAAcjD,IAAW,IAE5BjE,SAAW6T,EAAa7T,OAAS,EACpD,OAAOiE,ECZH,SAASiQ,GAAkBnV,GACjC,IAAO0U,GAAqB1U,GAC3B,OAAOA,EAGR,MAAM,KAAE4H,EAAF,aAAQO,EAAR,MAAsBvC,EAAtB,IAA6BE,GAAQ9F,EACrCoV,EAAoBpK,EAAchL,EAAO4F,GACzCf,EAAasD,EAAapD,MAAO,GACjCsQ,EACLlN,EAAc+M,GAAoBlV,EAAOoV,KAAyB,GAE7DE,ECdA,WAAoDhB,GAAY,IAApC,KAAE1M,EAAF,aAAQO,GAA4B,EACtE,MAAMoN,EAAcpN,EAAcmM,IAAe,GAEjD,IAAIkB,EAAalB,EAGjB,IAAM,IAAIpP,EAAQoP,GAAa,EAAGpP,EAAQ0C,EAAK3G,OAAQiE,IAEtD,GAAK0C,EAAM1C,KAAY0B,EAAvB,CAQA,MAJuBuB,EAAcjD,IAAW,IAI5BjE,QAAUsU,EAAYtU,QAGzC,OAAOuU,EAFPA,EAAatQ,EAOf,OAAOsQ,EDVgBC,CAAmBzV,EADlBgL,EAAchL,EAAO8F,IAM7C,IAAM,IAAIZ,EAAQkQ,EAAmBlQ,GAASoQ,EAAgBpQ,IAAU,CAEvE,GAAK0C,EAAM1C,KAAY0B,EACtB,SAID,MAAM8O,EAAiB7Q,EAAYK,IAAW,GAG9CL,EAAYK,GAAUmQ,EAAc9K,OACnCmL,EAAe3Q,MAAOsQ,EAAcpU,OAAS,IAGV,IAA/B4D,EAAYK,GAAQjE,eACjB4D,EAAYK,GAIrB,MAAO,IACHlF,EACHmI,aAActD,GEjCT,SAAS8Q,GAAgB3V,EAAO4V,GACtC,MAAM,KAAEhO,EAAF,aAAQO,EAAR,MAAsBvC,EAAtB,IAA6BE,GAAQ9F,EACrCoV,EAAoBpK,EAAchL,EAAO4F,GACzCiQ,EAAmB1N,EAAciN,IAAuB,GACxDU,EAAiB3N,EAAc6C,EAAchL,EAAO8F,KAAW,GAC/DH,EAAauP,GAAoBlV,EAAOoV,GACxCvI,EAAkB1E,EAAapD,QAC/BgR,EAAaF,EAAiB5U,OAAS,EACvC+U,EAAWF,EAAe7U,OAAS,EAEzC,IAAIgV,EAEJ,IAAM,IAAI/Q,EAAQS,EAAa,GAAK,EAAGT,EAAQ0C,EAAK3G,OAAQiE,IAC3D,GAAK0C,EAAM1C,KAAY0B,EAAvB,CAIA,IAAOiG,EAAiB3H,IAAW,IAAKjE,QAAU8U,EACjD,MAGMlJ,EAAiB3H,KAIxB+Q,GAAU,EACVpJ,EAAiB3H,GAAU2H,EAAiB3H,GAAQxD,KACnD,CAAE2D,EAAQrE,IACFA,EAAI+U,GAAc/U,EAAIgV,EAAW3Q,EAASuQ,KAKpD,OAAOK,EAIA,IACHjW,EACHmI,aAAc0E,GALP7M,ECzDT,MAAM,GAA+BC,OAAW,GAAW,QC4BpD,SAASiW,GAAT,GAAuD,IAAhC,IAAEC,EAAF,MAAOnW,EAAP,SAAc4L,EAAW,IAAO,EAC7D,MAAM,QAAErI,EAAF,UAAWD,EAAX,KAAsBJ,GAAS0I,EAC/BwK,EAAelT,EAAO2H,EAAiB7K,EAAOkD,QAAS6F,EAE7D,OAAOsN,EAAAA,GAAAA,UAAS,KACf,IAAOF,EAAItE,QAAU,OACrB,MACCb,eAAe,YAAEgB,IACdmE,EAAItE,QACFD,EAAYI,EAAYC,eAE9B,IAAOL,EAAUU,WAChB,OAGD,MAAMzK,EAAQ+J,EAAUW,WAAY,GAEpC,IAAO6D,EACN,OAAOvO,EAGR,IAAIF,EAAUE,EAAMa,eAKpB,IAFAf,EAAUA,EAAQ2O,oBAAsB3O,EAEhCA,EAAQqB,WAAarB,EAAQkC,cACpClC,EAAUA,EAAQc,WAGnB,OAAOd,EAAQ4O,QACdhT,GAAYD,EAAY,IAAMA,EAAY,OAEzC,CAAE8S,EAAcpW,EAAM4F,MAAO5F,EAAM8F,IAAKvC,EAASD,IC7DrD,MAAM,GAA+BrD,OAAW,GAAW,QCSpD,SAASuW,GAAT,GAAwC,IAAb,OAAEC,GAAW,EAC9C,MAAMN,GAAMO,EAAAA,GAAAA,WACN,cAAE3Q,EAAgB,IAAO0Q,EAAO5E,QAsCtC,OArCA8E,EAAAA,GAAAA,YAAW,KAGV,IAAO5Q,IAAmBA,EAAc9E,OACvC,OAGD,MAAM2V,EAAmB,oCACnBjP,EAAUwO,EAAItE,QAAQgF,cAAeD,GAE3C,IAAOjP,EACN,OAGD,MAAM,cAAEqJ,GAAkBrJ,GACpB,YAAEqK,GAAgBhB,EAOlBR,EAAS,oBAFuBoG,wBAJhB5E,EAAY8E,iBAAkBnP,GACrBoP,MAC7BvR,QAAS,IAAK,UACdA,QAAS,MAAO,WAIZwR,EAAgB,2BAEtB,IAAIC,EAAcjG,EAAckG,eAAgBF,GAEzCC,IACNA,EAAcjG,EAAc3K,cAAe,SAC3C4Q,EAAYE,GAAKH,EACjBhG,EAAc9O,KAAKiP,YAAa8F,IAG5BA,EAAYvQ,YAAc8J,IAC9ByG,EAAYvQ,UAAY8J,KAEvB,CAAEzK,IACEoQ,ECnCD,SAASiB,GAAgBC,GAC/B,MAAMC,GAAWZ,EAAAA,GAAAA,QAAQW,GAEzB,OADAC,EAASzF,QAAUwF,GACZE,EAAAA,GAAAA,eAAgB5P,IACtB,SAAS6P,EAAQC,GAChB,MAAM,OAAEhB,EAAF,aAAU3O,EAAV,mBAAwBI,GAC7BoP,EAASzF,QACV,GACCxG,EAAaoL,EAAO5E,WAClBlK,EAAQ+P,SAAU/P,EAAQqJ,cAAcqB,eAE1C,OAGD,MAAMsF,EAAiB5S,GAAO0R,EAAO5E,SAC/B+F,EAAY7M,EAAgB4M,GAC5BrR,EAAOkN,GAAc,CAC1BxT,MAAO2X,EACP7P,aAAAA,EACAI,mBAAAA,IAEDuP,EAAMI,cAAcC,QAAS,aAAcF,GAC3CH,EAAMI,cAAcC,QAAS,YAAaxR,GAC1CmR,EAAMI,cAAcC,QAAS,YAAa,QAC1CL,EAAMI,cAAcC,QACnB,2BACAhQ,GAAgB,IAEjB2P,EAAMM,iBAIP,OADApQ,EAAQqQ,iBAAkB,OAAQR,GAC3B,KACN7P,EAAQsQ,oBAAqB,OAAQT,MAEpC,ICjDJ,MAAM,GAA+BvX,OAAW,GAAY,SCYtDyK,GAAuB,GAEtB,SAASwN,GAAqBb,GACpC,MAAO,CAAGc,IAAgBC,EAAAA,GAAAA,aAAY,KAAM,MACtCd,GAAWZ,EAAAA,GAAAA,QAAQW,GAEzB,OADAC,EAASzF,QAAUwF,GACZE,EAAAA,GAAAA,eAAgB5P,IACtB,SAAS0Q,EAAWZ,GACnB,MAAM,QAAEa,EAAF,SAAWC,EAAX,OAAqBC,EAArB,QAA6BC,EAA7B,QAAsCC,GAAYjB,EAExD,GAECc,GACAC,GACAC,GACAC,GACEJ,IAAYK,GAAAA,MAAQL,IAAYM,GAAAA,MAElC,OAGD,MAAM,OAAEnC,EAAF,YAAUoC,GAAgBvB,EAASzF,SACnC,KACLjK,EADK,QAEL9C,EAFK,MAGLc,EAHK,IAILE,EACAC,cAAe+S,EAAuB,IACnCrC,EAAO5E,QACLtE,EAAYlC,EAAaoL,EAAO5E,UAChC,cAAEb,GAAkBrJ,GACpB,YAAEqK,GAAgBhB,GAElB,UAAE+H,GAAc/G,EAAY8E,iBAAkBnP,GAC9CqR,EAA2B,QAAdD,EAAsBH,GAAAA,MAAQD,GAAAA,KAC3CM,EAAYxB,EAAMa,UAAYU,EAMpC,GAAKzL,GAA6C,IAAhCuL,EAAqB7X,OAAe,CACrD,GAAe,IAAV2E,GAAeqT,EACnB,OAGD,GAAKnT,IAAQ8B,EAAK3G,SAAYgY,EAC7B,OAOF,IAAO1L,EACN,OAGD,MAAM5C,EAAgB7F,EAASc,EAAQ,IAAO8E,GACxCE,EAAe9F,EAASc,IAAW8E,GACnCwO,EAAcD,EAAYtO,EAAgBC,EAC1CuO,EAAeL,EAAqBM,OACzC,CAAE/T,EAAQH,IAAWG,IAAW6T,EAAahU,KAG9C,IAAImU,EAAyBP,EAAqB7X,OAQlD,GANOkY,EAEKE,EAAyBH,EAAYjY,QAChDoY,IAFAA,IAKIA,IAA2BP,EAAqB7X,OAEpD,YADAwV,EAAO5E,QAAQyH,kBAAoBJ,GAIpCzB,EAAMM,iBAEN,MAEMwB,GADSJ,EAAeD,EADfD,EAAYrO,EAAeD,GAEV5F,MAAO,EAAGsU,GACpC7L,EAAW,IACbiJ,EAAO5E,QACV9L,cAAewT,GAEhB9C,EAAO5E,QAAUrE,EACjBqL,EAAarL,GACb2K,IAID,OADAxQ,EAAQqQ,iBAAkB,UAAWK,GAC9B,KACN1Q,EAAQsQ,oBAAqB,UAAWI,MAEvC,IC9FG,SAASmB,GAA0BnC,GACzC,MAAMC,GAAWZ,EAAAA,GAAAA,QAAQW,GAEzB,OADAC,EAASzF,QAAUwF,GACZE,EAAAA,GAAAA,eAAgB5P,IACtB,SAAS0Q,EAAWZ,GACnB,MAAM,QAAEa,EAAF,SAAWC,EAAX,OAAqBC,EAArB,QAA6BC,EAA7B,QAAsCC,GAAYjB,GAClD,aAAE3P,EAAF,aAAgB2R,EAAhB,aAA8BC,GACnCpC,EAASzF,QAEV,GAEC0G,GACAC,GACAC,GACAC,GACAJ,IAAYqB,GAAAA,OACK,OAAjB7R,EAEA,OAGD,MAAM8R,EAAeH,IAErB,IAAOpO,EAAauO,GACnB,OAGD,MAAM,KAAEhS,EAAF,MAAQhC,GAAUgU,EAClBC,EAAkBjS,EAAMhC,EAAQ,GAGjCiU,GAAmBA,IAAoBjT,IAI5C8S,EACC/E,GAAiBiF,EAAc,CAC9BtZ,KAAMqH,EAAQpE,QAAQqG,iBAGxB6N,EAAMM,kBAIP,OADApQ,EAAQqQ,iBAAkB,UAAWK,GAC9B,KACN1Q,EAAQsQ,oBAAqB,UAAWI,MAEvC,IC1CJ,MAAMyB,GAAkC,IAAIC,IAAK,CAChD,kBACA,oBACA,sBACA,uBACA,eAGKrP,GAAuB,GA6BtB,SAASsP,GAAsB3C,GACrC,MAAMC,GAAWZ,EAAAA,GAAAA,QAAQW,GAEzB,OADAC,EAASzF,QAAUwF,GACZE,EAAAA,GAAAA,eAAgB5P,IACtB,MAAM,cAAEqJ,GAAkBrJ,GACpB,YAAEqK,GAAgBhB,EAExB,IACIiJ,EADAC,GAAc,EAGlB,SAASC,EAAS1C,GAMjB,GAAKyC,EACJ,OAGD,IAAIE,EAEC3C,IACJ2C,EAAY3C,EAAM2C,WAGnB,MAAM,OAAE3D,EAAF,YAAUoC,EAAV,aAAuBY,EAAvB,aAAqCC,GAC1CpC,EAASzF,QAKV,GACCuI,IACoC,IAAlCA,EAAU1W,QAAS,WACpBoW,GAAgChY,IAAKsY,IAGtC,YADAvB,EAAapC,EAAO5E,SAIrB,MAAM+H,EAAeH,KACf,MAAE7T,EAAOG,cAAesU,EAAmB,IAChD5D,EAAO5E,QAUR6H,ECzFI,YAAyD,IAAjC,MAAE1Z,EAAF,MAAS4F,EAAT,IAAgBE,EAAhB,QAAqBhB,GAAY,EAE/D,MAAMwV,EAAMC,KAAKD,IAAK1U,EAAOE,GACvB0U,EAAMD,KAAKC,IAAK5U,EAAOE,GACvB6E,EAAgB3K,EAAM8E,QAASwV,EAAM,IAAO,GAC5C1P,EAAe5K,EAAM8E,QAAS0V,IAAS,GAkB7C,IAdAxa,EAAM+F,cAAgBjB,EAAQpD,KAAK,CAAE2D,EAAQH,KAC5C,GAAKyF,EAAezF,IACnB,GAAKf,EAAekB,EAAQsF,EAAezF,IAC1C,OAAOyF,EAAezF,QAEjB,GAAK0F,EAAc1F,IACpBf,EAAekB,EAAQuF,EAAc1F,IACzC,OAAO0F,EAAc1F,GAIvB,OAAOG,OAGES,GAAOF,GACX5F,EAAM+F,cAAc9E,OAAS,EACjCjB,EAAM8E,QAASgB,GAAQ9F,EAAM+F,qBAEtB/F,EAAM8E,QAASgB,GAIxB,OAAO9F,EDmDUya,CAAe,CAC7Bza,MAAO4Z,EACPhU,MAAAA,EACAE,IAAK8T,EAAahU,MAClBd,QAASuV,KAaX,SAASK,EAAuBjD,GAC/B,MAAM,OACLhB,EADK,YAELoC,EAFK,aAGLY,EAHK,WAILkB,EAJK,kBAKLC,GACGtD,EAASzF,QAKb,GAAiC,SAA5BlK,EAAQkT,gBACZ,OAOD,GAAK7J,EAAcqB,gBAAkB1K,EAAU,CAC9C,IAAOqJ,EAAcqB,cAAcqF,SAAU/P,GAC5C,OAGD,MAAMiK,EAAYI,EAAYC,gBACxB,WAAE6I,EAAF,UAAcC,GAAcnJ,EAElC,GACCjK,EAAQ+P,SAAUoD,IAClBnT,IAAYmT,GACZnT,EAAQ+P,SAAUqD,IAClBpT,IAAYoT,EACX,CACD,MAAM,MAAEnV,EAAF,IAASE,GAAQ2T,IACvBhD,EAAO5E,QAAQ9L,cAAgB2E,GAC/BkQ,EAAmBhV,EAAOE,QACpB,GACN6B,EAAQ+P,SAAUoD,IAClBnT,IAAYmT,EACX,CACD,MAAM,MAAElV,EAAOE,IAAK8G,EAAShH,GAAU6T,IACvChD,EAAO5E,QAAQ9L,cAAgB2E,GAC/BkQ,EAAmBhO,QACb,GACNjF,EAAQ+P,SAAUqD,IAClBpT,IAAYoT,EACX,CACD,MAAM,MAAEnV,EAAOE,IAAK8G,EAAShH,GAAU6T,IACvChD,EAAO5E,QAAQ9L,cAAgB2E,GAC/BkQ,OAAmB7R,EAAW6D,GAE/B,OAGD,GAAoB,oBAAf6K,EAAMnX,OAAgCqa,EAC1C,OAKD,GAAKT,EACJ,OAGD,MAAM,MAAEtU,EAAF,IAASE,EAAT,KAAc8B,GAAS6R,IACvBuB,EAAYvE,EAAO5E,QAIzB,GAAKjK,IAASoT,EAAUpT,KAEvB,YADAuS,IAID,GAAKvU,IAAUoV,EAAUpV,OAASE,IAAQkV,EAAUlV,IAQnD,YAJ+B,IAA1BkV,EAAUpT,KAAK3G,QAA0B,IAAV2E,GAnKxC,SAAkCoM,GACjC,MAAMJ,EAAYI,EAAYC,gBACxB,WAAE6I,EAAF,aAAcG,GAAiBrJ,EAErC,GAAKkJ,EAAW9R,WAAa8R,EAAWjR,aACvC,OAGD,MAAMqR,EAAaJ,EAAW5R,WAAY+R,GAGvCC,GACFA,EAAWlS,WAAakS,EAAWrR,cACjCqR,EAAWpR,aAAc,+BAK5B8H,EAAUuJ,kBAkJNC,CAAyBpJ,IAM3B,MAAMxE,EAAW,IACbwN,EACHpV,MAAAA,EACAE,IAAAA,EAIAC,cAAeiV,EAAU1B,kBACzBA,uBAAmBvQ,GAGdwQ,EAAmB9O,EACxB+C,EACA9C,IAID8C,EAASzH,cAAgBwT,EAIzB9C,EAAO5E,QAAUrE,EACjBqL,EAAarL,EAAU,CAAE6N,SAAS,IAClCT,EAAmBhV,EAAOE,GAG3B,SAASwV,IACRpB,GAAc,EAIdlJ,EAAciH,oBACb,kBACAyC,GAIF,SAASa,IACRrB,GAAc,EAGdC,EAAS,CAAEC,UAAW,eAEtBpJ,EAAcgH,iBACb,kBACA0C,GAIF,SAASc,IACR,MAAM,OAAE/E,EAAF,WAAUkE,EAAV,kBAAsBC,EAAtB,YAAyC/B,GAC9CvB,EAASzF,QAIV,IAAKlK,EAAQ8T,cAAclF,QAAS,4BAApC,CAIA,GAAOoE,EAcN9B,EAAapC,EAAO5E,SACpB+I,EAAmBnE,EAAO5E,QAAQjM,MAAO6Q,EAAO5E,QAAQ/L,SAfrC,CAInB,MAAMZ,OAAQ6D,EAEd0N,EAAO5E,QAAU,IACb4E,EAAO5E,QACVjM,MAAOV,EACPY,IAAKZ,EACLa,cAAe2E,IAEhBkQ,EAAmB1V,EAAOA,GAU3B+U,EAAQjI,EAAY0J,sBAAuBhB,IAkB5C,OAfA/S,EAAQqQ,iBAAkB,QAASmC,GACnCxS,EAAQqQ,iBAAkB,mBAAoBsD,GAC9C3T,EAAQqQ,iBAAkB,iBAAkBuD,GAC5C5T,EAAQqQ,iBAAkB,QAASwD,GAKnC7T,EAAQqQ,iBAAkB,QAAS0C,GACnC/S,EAAQqQ,iBAAkB,UAAW0C,GACrC/S,EAAQqQ,iBAAkB,WAAY0C,GACtC1J,EAAcgH,iBACb,kBACA0C,GAEM,KACN/S,EAAQsQ,oBAAqB,QAASkC,GACtCxS,EAAQsQ,oBACP,mBACAqD,GAED3T,EAAQsQ,oBAAqB,iBAAkBsD,GAC/C5T,EAAQsQ,oBAAqB,QAASuD,GACtC7T,EAAQsQ,oBAAqB,QAASyC,GACtC/S,EAAQsQ,oBAAqB,UAAWyC,GACxC/S,EAAQsQ,oBAAqB,WAAYyC,GACzC1J,EAAciH,oBACb,kBACAyC,GAED1I,EAAY2J,qBAAsB1B,MAEjC,IEnTG,SAAS2B,GAAWvE,GAC1B,MAAMC,GAAWZ,EAAAA,GAAAA,QAAQW,GAEzB,OADAC,EAASzF,QAAUwF,GACZE,EAAAA,GAAAA,eAAgB5P,IACtB,SAAS0Q,EAAWZ,GACnB,MAAM,QAAEa,GAAYb,GACd,aAAEgC,EAAF,aAAgBC,EAAhB,aAA8B5R,GACnCwP,EAASzF,QAEV,GAAK4F,EAAMoE,iBACV,OAGD,GAAKvD,IAAYwD,GAAAA,QAAUxD,IAAYyD,GAAAA,UACtC,OAGD,MAAMnC,EAAeH,KACf,MAAE7T,EAAF,IAASE,EAAT,KAAc8B,GAASgS,EACvBX,EAAYX,IAAYyD,GAAAA,UAG9B,GAAe,IAAVnW,GAAuB,IAARE,GAAaA,IAAQ8B,EAAK3G,OAG7C,OAFAyY,EAAclN,EAAQoN,SACtBnC,EAAMM,iBAIP,GAAKjQ,EAAe,CACnB,IAAI0F,EASHA,EALAyL,GACuB,IAAvBW,EAAahU,OACQ,IAArBgU,EAAa9T,KACbyF,EAAaqO,GAEFvM,EAAqBuM,GAAgBX,GAErC5L,EAAqBuM,EAAcX,GAG1CzL,IACJkM,EAAclM,GACdiK,EAAMM,mBAMT,OADApQ,EAAQqQ,iBAAkB,UAAWK,GAC9B,KACN1Q,EAAQsQ,oBAAqB,UAAWI,MAEvC,IC7CG,SAAS2D,GAAT,GAeH,IAfyB,MAC5Bhc,EAAQ,GADoB,eAE5Bic,EAF4B,aAG5BC,EAH4B,YAI5B5M,EAJ4B,mBAK5BpH,EAL4B,kBAM5B0S,EAN4B,SAO5BuB,EACAC,uBAAwBtU,EACxBuU,yBAA0BC,EAC1BC,qBAAsB5B,EAVM,uBAW5B6B,EAAyB,GAXG,qBAY5BC,EAZ4B,0BAa5BC,EAb4B,8BAc5BC,GACG,EACH,MAAMC,GAAWC,EAAAA,EAAAA,gBACV,CAAG1E,IAAgBC,EAAAA,GAAAA,aAAY,KAAM,MACtCjC,GAAMO,EAAAA,GAAAA,UAEZ,SAAS+C,IACR,MACCzI,eAAe,YAAEgB,IACdmE,EAAItE,QACFD,EAAYI,EAAYC,eACxBpK,EACL+J,EAAUU,WAAa,EAAIV,EAAUW,WAAY,GAAM,KAExD,OAAO7K,EAAQ,CACdC,QAASwO,EAAItE,QACbhK,MAAAA,EACAC,aAAAA,EACAC,qBACkB,OAAjBD,EAAwB,CAAE,KAAM,WAASiB,EAC1Cf,0BAA0B,EAC1BE,mBAAAA,IAIF,SAAS2Q,EAAaiE,GAA8B,IAAnB,QAAEzB,GAAiB,uDAAL,GAC9C3Y,GAAO,CACN1C,MAAO8c,EACPjL,QAASsE,EAAItE,QACb/J,aAAAA,EACAC,qBACkB,OAAjBD,EAAwB,CAAE,KAAM,WAASiB,EAC1CyI,oBAAqBmL,EACrB7K,kBAAmBuJ,EACnB/L,YAAAA,IAKF,MAAMyN,GAASrG,EAAAA,GAAAA,QAAQ1W,GACjByW,GAASC,EAAAA,GAAAA,UAEf,SAASsG,IACRD,EAAOlL,QAAU7R,EACjByW,EAAO5E,QAAUnK,EAAQ,CACxBpB,KAAMtG,EACN8H,aAAAA,EACAC,qBACkB,OAAjBD,EAAwB,CAAE,KAAM,WAASiB,EAC1Cb,mBAAAA,IAEIoU,IACJ7F,EAAO5E,QAAQ/M,QAAUrC,MAAOzC,EAAMiB,QACtCwV,EAAO5E,QAAQ1J,aAAe1F,MAAOzC,EAAMiB,SAEvCwb,IACJhG,EAAO5E,QAAQ/M,QAAU2X,EAAsBhG,EAAO5E,UAEvD4E,EAAO5E,QAAQjM,MAAQqW,EACvBxF,EAAO5E,QAAQ/L,IAAMoW,EAGtB,MAAMe,GAAqBvG,EAAAA,GAAAA,SAAQ,GAEX,UAAjBD,EAAO5E,QAkBboK,IAAmBxF,EAAO5E,QAAQjM,OAClCsW,IAAiBzF,EAAO5E,QAAQ/L,MAEhCmX,EAAmBpL,QAAU8I,EAC7BlE,EAAO5E,QAAU,IACb4E,EAAO5E,QACVjM,MAAOqW,EACPnW,IAAKoW,KAxBNc,IAW+C,qBAA9C,UAAAvG,EAAO5E,eAAP,mBAAgB/M,QAAS,UAAzB,mBAAgC,UAAhC,eAAqCxE,OAyDvC,SAAgCwc,GAC/BrG,EAAO5E,QAAUiL,EAEjBC,EAAOlL,QAAU2B,GAAc,CAC9BxT,MAAO0c,EACJ,IACGI,EACHhY,QAAS4X,EAA2BI,IAEpCA,EACHhV,aAAAA,EACAI,mBAAAA,IAGD,MAAM,QAAEpD,EAAF,KAAW8C,GAASkV,EAE1BF,EAASM,OAAO,KACff,EAAUY,EAAOlL,QAAS,CACzBsL,kBAAmBrY,EACnBsY,eAAgBxV,OAGlBuQ,IA5ECkF,CAAuB5G,EAAO5E,UAoBhC,SAAS6H,EAAcoD,GACtBrG,EAAO5E,QAAUiL,EACjBjE,EAAaiE,GAGZC,EAAOlL,QADHyK,EACaQ,EAAUlV,KAEV4L,GAAc,CAC9BxT,MAAO0c,EACJ,IACGI,EACHhY,QAAS4X,EAA2BI,IAEpCA,EACHhV,aAAAA,EACAI,mBAAAA,IAIF,MAAM,MAAEtC,EAAF,IAASE,EAAT,QAAchB,EAAd,KAAuB8C,GAASkV,EAKtCF,EAASM,OAAO,KACftC,EAAmBhV,EAAOE,GAC1BqW,EAAUY,EAAOlL,QAAS,CACzBsL,kBAAmBrY,EACnBsY,eAAgBxV,OAGlBuQ,IA4BD,SAASmF,IACRN,IACAnE,EAAapC,EAAO5E,SAGrB,MAAM0L,GAAW7G,EAAAA,GAAAA,SAAQ,IAGzB8G,EAAAA,GAAAA,kBAAiB,KACXD,EAAS1L,SAAW7R,IAAU+c,EAAOlL,UACzCyL,IACAnF,OAEC,CAAEnY,KAGLwd,EAAAA,GAAAA,kBAAiB,KACTP,EAAmBpL,UAIrBsE,EAAItE,QAAQb,cAAcqB,gBAAkB8D,EAAItE,SACpDsE,EAAItE,QAAQc,QAGb2K,IACAL,EAAmBpL,SAAU,KAC3B,CAAEoL,EAAmBpL,UAExB,MAAM4L,GAAaC,EAAAA,GAAAA,cAAc,CAChCvH,GC/LMwH,EAAAA,GAAAA,cAAehW,IACdA,IACPA,EAAQ6I,MAAMoN,WAXG,WAYjBjW,EAAQ6I,MAAMqN,SANC,SAOb,ID6LFrH,GAAkB,CAAEC,OAAAA,IACpBW,GAAgB,CAAEX,OAAAA,EAAQ3O,aAAAA,EAAcI,mBAAAA,KE9NlCqP,EAAAA,GAAAA,eAAgB5P,IACtB,SAASmW,EAASrG,GACjB,MAAM,OAAEsG,GAAWtG,EAGnB,GAAKsG,IAAWpW,GAAWoW,EAAOC,YACjC,OAGD,MAAM,cAAEhN,GAAkB+M,GACpB,YAAE/L,GAAgBhB,EAClBnJ,EAAQmJ,EAAckB,cACtBN,EAAYI,EAAYC,eAE9BpK,EAAMoW,WAAYF,GAClBnM,EAAUY,kBACVZ,EAAUa,SAAU5K,GAIrB,OADAF,EAAQqQ,iBAAkB,QAAS8F,GAC5B,KACNnW,EAAQsQ,oBAAqB,QAAS6F,MAErC,IFyMF5F,GAAqB,CAAEzB,OAAAA,EAAQoC,YAAAA,IAC/B+C,GAAW,CACVnC,aAAAA,EACAC,aAAAA,EACA5R,aAAAA,IAED0R,GAA0B,CACzB1R,aAAAA,EACA2R,aAAAA,EACAC,aAAAA,IAEDM,GAAsB,CACrBvD,OAAAA,EACAoC,YAAAA,EACAY,aAAAA,EACAC,aAAAA,EACAiB,WAAAA,EACAC,kBAAAA,KGvOKrD,EAAAA,GAAAA,eAAgB5P,IACtB,SAAS0Q,EAAWZ,GAEnB,GAAKA,EAAMoE,iBACV,OAGD,MAAM,QAAEvD,EAAF,OAAWE,EAAX,QAAmBC,EAAnB,QAA4BC,EAA5B,IAAqCvZ,GAAQsY,EAG9Ca,IAAYqB,GAAAA,OAASnB,GAAUC,GAAWC,GAyBlC,MAARvZ,IAILsY,EAAMsG,OAAO/M,cAAckN,YAAa,cAAc,EAAO,KAC7DzG,EAAMM,kBAIP,OADApQ,EAAQqQ,iBAAkB,UAAWK,GAC9B,KACN1Q,EAAQsQ,oBAAqB,UAAWI,MAEvC,KH2LFd,EAAAA,GAAAA,eAAc,KACb+F,IACAC,EAAS1L,SAAU,IACjB,CAAEvC,KAAgBkN,MAGtB,MAAO,CACNxc,MAAOyW,EAAO5E,QACdsK,SAAUzC,EACVvD,IAAKsH,GAIQ,SAASU,MIjQT,SAASC,GAAT,GAMX,IANgC,YACnCje,EADmC,SAEnCgc,EAFmC,QAGnCX,EAHmC,MAInCxb,EAJmC,aAKnCqe,GACG,EACH,OAAOle,EAAYuB,KAAOkK,IACzB,MAAM,KAAE1I,EAAMob,KAAMC,GAAS3S,EAE7B,IAAO2S,EACN,OAAO,KAGR,MAAMnI,EAAevL,EAAiB7K,EAAOkD,GACvCsb,OAA4BzV,IAAjBqN,EACXqI,EAAe3T,EAAiB9K,GAChC0e,OACY3V,IAAjB0V,GAA8BA,EAAane,OAAS4C,EAErD,OACC,oBAACqb,EAAD,CACCpf,IAAM+D,EACNsb,SAAWA,EACXG,iBACCH,GAAWpI,EAAa7R,YAAmB,GAE5Cma,eAAiBA,EACjBE,uBACCF,GAAiBD,EAAala,YAAmB,GAElDvE,MAAQA,EACRmc,SAAWA,EACXX,QAAUA,EACVqD,WAAaR,Q","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","webpack://wp/external window [\"wp\",\"data\"]","webpack://wp/external window \"lodash\"","webpack://wp/./packages/rich-text/build-module/store/@wordpress/rich-text/src/store/reducer.js","webpack://wp/./node_modules/rememo/es/rememo.js","webpack://wp/./packages/rich-text/build-module/store/@wordpress/rich-text/src/store/selectors.js","webpack://wp/./packages/rich-text/build-module/store/@wordpress/rich-text/src/store/actions.js","webpack://wp/./packages/rich-text/build-module/store/@wordpress/rich-text/src/store/index.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/is-format-equal.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/normalise-formats.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/apply-format.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/create-element.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/special-characters.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/create.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/concat.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-active-formats.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-active-format.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-active-object.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-text-content.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-line-index.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/is-list-root-selected.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/is-active-list-type.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/is-collapsed.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/is-empty.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/join.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/register-format-type.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/remove-format.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/insert.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/remove.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/replace.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/insert-line-separator.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/remove-line-separator.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/insert-object.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/slice.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/split.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/to-tree.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-format-type.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/to-dom.js","webpack://wp/external window [\"wp\",\"escapeHtml\"]","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/to-html-string.js","webpack://wp/external window [\"wp\",\"a11y\"]","webpack://wp/external window [\"wp\",\"i18n\"]","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/toggle-format.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/unregister-format-type.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/can-indent-list-items.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/can-outdent-list-items.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/indent-list-items.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-parent-line-index.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/outdent-list-items.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/get-last-child-index.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/change-list-type.js","webpack://wp/external window [\"wp\",\"element\"]","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-anchor-ref.js","webpack://wp/external window [\"wp\",\"compose\"]","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-boundary-style.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-copy-handler.js","webpack://wp/external window [\"wp\",\"keycodes\"]","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-format-boundaries.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-indent-list-item-on-space.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-input-and-selection.js","webpack://wp/./packages/rich-text/build-module/@wordpress/rich-text/src/update-formats.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-delete.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/index.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-default-style.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-select-object.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/use-space.js","webpack://wp/./packages/rich-text/build-module/component/@wordpress/rich-text/src/component/format-edit.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"data\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"lodash\"];","/**\n * External dependencies\n */\nimport { keyBy, omit } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nexport function formatTypes( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ADD_FORMAT_TYPES':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t...keyBy( action.formatTypes, 'name' ),\n\t\t\t};\n\t\tcase 'REMOVE_FORMAT_TYPES':\n\t\t\treturn omit( state, action.names );\n\t}\n\n\treturn state;\n}\n\nexport default combineReducers( { formatTypes } );\n","'use strict';\n\n/** @typedef {(...args: any[]) => *[]} GetDependants */\n\n/** @typedef {() => void} Clear */\n\n/**\n * @typedef {{\n *   getDependants: GetDependants,\n *   clear: Clear\n * }} EnhancedSelector\n */\n\n/**\n * Internal cache entry.\n *\n * @typedef CacheNode\n *\n * @property {?CacheNode|undefined} [prev] Previous node.\n * @property {?CacheNode|undefined} [next] Next node.\n * @property {*[]} args Function arguments for cache entry.\n * @property {*} val Function result.\n */\n\n/**\n * @typedef Cache\n *\n * @property {Clear} clear Function to clear cache.\n * @property {boolean} [isUniqueByDependants] Whether dependants are valid in\n * considering cache uniqueness. A cache is unique if dependents are all arrays\n * or objects.\n * @property {CacheNode?} [head] Cache head.\n * @property {*[]} [lastDependants] Dependants from previous invocation.\n */\n\n/**\n * Arbitrary value used as key for referencing cache object in WeakMap tree.\n *\n * @type {{}}\n */\nvar LEAF_KEY = {};\n\n/**\n * Returns the first argument as the sole entry in an array.\n *\n * @template T\n *\n * @param {T} value Value to return.\n *\n * @return {[T]} Value returned as entry in array.\n */\nfunction arrayOf(value) {\n\treturn [value];\n}\n\n/**\n * Returns true if the value passed is object-like, or false otherwise. A value\n * is object-like if it can support property assignment, e.g. object or array.\n *\n * @param {*} value Value to test.\n *\n * @return {boolean} Whether value is object-like.\n */\nfunction isObjectLike(value) {\n\treturn !!value && 'object' === typeof value;\n}\n\n/**\n * Creates and returns a new cache object.\n *\n * @return {Cache} Cache object.\n */\nfunction createCache() {\n\t/** @type {Cache} */\n\tvar cache = {\n\t\tclear: function () {\n\t\t\tcache.head = null;\n\t\t},\n\t};\n\n\treturn cache;\n}\n\n/**\n * Returns true if entries within the two arrays are strictly equal by\n * reference from a starting index.\n *\n * @param {*[]} a First array.\n * @param {*[]} b Second array.\n * @param {number} fromIndex Index from which to start comparison.\n *\n * @return {boolean} Whether arrays are shallowly equal.\n */\nfunction isShallowEqual(a, b, fromIndex) {\n\tvar i;\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (i = fromIndex; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns a memoized selector function. The getDependants function argument is\n * called before the memoized selector and is expected to return an immutable\n * reference or array of references on which the selector depends for computing\n * its own return value. The memoize cache is preserved only as long as those\n * dependant references remain the same. If getDependants returns a different\n * reference(s), the cache is cleared and the selector value regenerated.\n *\n * @template {(...args: *[]) => *} S\n *\n * @param {S} selector Selector function.\n * @param {GetDependants=} getDependants Dependant getter returning an array of\n * references used in cache bust consideration.\n */\nexport default function (selector, getDependants) {\n\t/** @type {WeakMap<*,*>} */\n\tvar rootCache;\n\n\t/** @type {GetDependants} */\n\tvar normalizedGetDependants = getDependants ? getDependants : arrayOf;\n\n\t/**\n\t * Returns the cache for a given dependants array. When possible, a WeakMap\n\t * will be used to create a unique cache for each set of dependants. This\n\t * is feasible due to the nature of WeakMap in allowing garbage collection\n\t * to occur on entries where the key object is no longer referenced. Since\n\t * WeakMap requires the key to be an object, this is only possible when the\n\t * dependant is object-like. The root cache is created as a hierarchy where\n\t * each top-level key is the first entry in a dependants set, the value a\n\t * WeakMap where each key is the next dependant, and so on. This continues\n\t * so long as the dependants are object-like. If no dependants are object-\n\t * like, then the cache is shared across all invocations.\n\t *\n\t * @see isObjectLike\n\t *\n\t * @param {*[]} dependants Selector dependants.\n\t *\n\t * @return {Cache} Cache object.\n\t */\n\tfunction getCache(dependants) {\n\t\tvar caches = rootCache,\n\t\t\tisUniqueByDependants = true,\n\t\t\ti,\n\t\t\tdependant,\n\t\t\tmap,\n\t\t\tcache;\n\n\t\tfor (i = 0; i < dependants.length; i++) {\n\t\t\tdependant = dependants[i];\n\n\t\t\t// Can only compose WeakMap from object-like key.\n\t\t\tif (!isObjectLike(dependant)) {\n\t\t\t\tisUniqueByDependants = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Does current segment of cache already have a WeakMap?\n\t\t\tif (caches.has(dependant)) {\n\t\t\t\t// Traverse into nested WeakMap.\n\t\t\t\tcaches = caches.get(dependant);\n\t\t\t} else {\n\t\t\t\t// Create, set, and traverse into a new one.\n\t\t\t\tmap = new WeakMap();\n\t\t\t\tcaches.set(dependant, map);\n\t\t\t\tcaches = map;\n\t\t\t}\n\t\t}\n\n\t\t// We use an arbitrary (but consistent) object as key for the last item\n\t\t// in the WeakMap to serve as our running cache.\n\t\tif (!caches.has(LEAF_KEY)) {\n\t\t\tcache = createCache();\n\t\t\tcache.isUniqueByDependants = isUniqueByDependants;\n\t\t\tcaches.set(LEAF_KEY, cache);\n\t\t}\n\n\t\treturn caches.get(LEAF_KEY);\n\t}\n\n\t/**\n\t * Resets root memoization cache.\n\t */\n\tfunction clear() {\n\t\trootCache = new WeakMap();\n\t}\n\n\t/* eslint-disable jsdoc/check-param-names */\n\t/**\n\t * The augmented selector call, considering first whether dependants have\n\t * changed before passing it to underlying memoize function.\n\t *\n\t * @param {*}    source    Source object for derivation.\n\t * @param {...*} extraArgs Additional arguments to pass to selector.\n\t *\n\t * @return {*} Selector result.\n\t */\n\t/* eslint-enable jsdoc/check-param-names */\n\tfunction callSelector(/* source, ...extraArgs */) {\n\t\tvar len = arguments.length,\n\t\t\tcache,\n\t\t\tnode,\n\t\t\ti,\n\t\t\targs,\n\t\t\tdependants;\n\n\t\t// Create copy of arguments (avoid leaking deoptimization).\n\t\targs = new Array(len);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\tdependants = normalizedGetDependants.apply(null, args);\n\t\tcache = getCache(dependants);\n\n\t\t// If not guaranteed uniqueness by dependants (primitive type), shallow\n\t\t// compare against last dependants and, if references have changed,\n\t\t// destroy cache to recalculate result.\n\t\tif (!cache.isUniqueByDependants) {\n\t\t\tif (\n\t\t\t\tcache.lastDependants &&\n\t\t\t\t!isShallowEqual(dependants, cache.lastDependants, 0)\n\t\t\t) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\n\t\t\tcache.lastDependants = dependants;\n\t\t}\n\n\t\tnode = cache.head;\n\t\twhile (node) {\n\t\t\t// Check whether node arguments match arguments\n\t\t\tif (!isShallowEqual(node.args, args, 1)) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point we can assume we've found a match\n\n\t\t\t// Surface matched node to head if not already\n\t\t\tif (node !== cache.head) {\n\t\t\t\t// Adjust siblings to point to each other.\n\t\t\t\t/** @type {CacheNode} */ (node.prev).next = node.next;\n\t\t\t\tif (node.next) {\n\t\t\t\t\tnode.next.prev = node.prev;\n\t\t\t\t}\n\n\t\t\t\tnode.next = cache.head;\n\t\t\t\tnode.prev = null;\n\t\t\t\t/** @type {CacheNode} */ (cache.head).prev = node;\n\t\t\t\tcache.head = node;\n\t\t\t}\n\n\t\t\t// Return immediately\n\t\t\treturn node.val;\n\t\t}\n\n\t\t// No cached value found. Continue to insertion phase:\n\n\t\tnode = /** @type {CacheNode} */ ({\n\t\t\t// Generate the result from original function\n\t\t\tval: selector.apply(null, args),\n\t\t});\n\n\t\t// Avoid including the source object in the cache.\n\t\targs[0] = null;\n\t\tnode.args = args;\n\n\t\t// Don't need to check whether node is already head, since it would\n\t\t// have been returned above already if it was\n\n\t\t// Shift existing head down list\n\t\tif (cache.head) {\n\t\t\tcache.head.prev = node;\n\t\t\tnode.next = cache.head;\n\t\t}\n\n\t\tcache.head = node;\n\n\t\treturn node.val;\n\t}\n\n\tcallSelector.getDependants = normalizedGetDependants;\n\tcallSelector.clear = clear;\n\tclear();\n\n\treturn /** @type {S & EnhancedSelector} */ (callSelector);\n}\n","/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport { find } from 'lodash';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [ state.formatTypes ]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Format type name.\n *\n * @return {Object?} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForBareElement( state, bareElementTagName ) {\n\treturn find( getFormatTypes( state ), ( { className, tagName } ) => {\n\t\treturn className === null && bareElementTagName === tagName;\n\t} );\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForClassName( state, elementClassName ) {\n\treturn find( getFormatTypes( state ), ( { className } ) => {\n\t\tif ( className === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ` ${ elementClassName } `.indexOf( ` ${ className } ` ) >= 0;\n\t} );\n}\n","/**\n * External dependencies\n */\nimport { castArray } from 'lodash';\n\n/**\n * Returns an action object used in signalling that format types have been\n * added.\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nexport function addFormatTypes( formatTypes ) {\n\treturn {\n\t\ttype: 'ADD_FORMAT_TYPES',\n\t\tformatTypes: castArray( formatTypes ),\n\t};\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nexport function removeFormatTypes( names ) {\n\treturn {\n\t\ttype: 'REMOVE_FORMAT_TYPES',\n\t\tnames: castArray( names ),\n\t};\n}\n","/**\n * WordPress dependencies\n */\nimport { createReduxStore, register } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as actions from './actions';\n\nconst STORE_NAME = 'core/rich-text';\n\n/**\n * Store definition for the rich-text namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n *\n * @type {Object}\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tselectors,\n\tactions,\n} );\n\nregister( store );\n","/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Optimised equality check for format objects.\n *\n * @param {?RichTextFormat} format1 Format to compare.\n * @param {?RichTextFormat} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Normalises formats: ensures subsequent adjacent equal formats have the same\n * reference.\n *\n * @param {RichTextValue} value Value to normalise formats of.\n *\n * @return {RichTextValue} New value with normalised formats.\n */\nexport function normaliseFormats( value ) {\n\tconst newFormats = value.formats.slice();\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst formatsAtPreviousIndex = newFormats[ index - 1 ];\n\n\t\tif ( formatsAtPreviousIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice();\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst previousFormat = formatsAtPreviousIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, previousFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = previousFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn {\n\t\t...value,\n\t\tformats: newFormats,\n\t};\n}\n","/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], {\n\t\t\ttype: format.type,\n\t\t} );\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...reject( activeFormats, { type: format.type } ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n","/**\n * Parse the given HTML into a body element.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createElement`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\t// Because `createHTMLDocument` is an expensive operation, and with this\n\t// function being internal to `rich-text` (full control in avoiding a risk\n\t// of asynchronous operations on the shared reference), a single document\n\t// is reused and reset for each call to the function.\n\tif ( ! createElement.body ) {\n\t\tcreateElement.body = implementation.createHTMLDocument( '' ).body;\n\t}\n\n\tcreateElement.body.innerHTML = html;\n\n\treturn createElement.body;\n}\n","/**\n * Line separator character, used for multiline text.\n */\nexport const LINE_SEPARATOR = '\\u2028';\n\n/**\n * Object replacement character, used as a placeholder for objects.\n */\nexport const OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Zero width non-breaking space, used as padding in the editable DOM tree when\n * it is empty otherwise.\n */\nexport const ZWNBSP = '\\ufeff';\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\nimport { createElement } from './create-element';\nimport { mergePair } from './concat';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\n/**\n * @typedef {Object} RichTextFormat\n *\n * @property {string} type Format type.\n */\n\n/**\n * @typedef {Array<RichTextFormat>} RichTextFormatList\n */\n\n/**\n * @typedef {Object} RichTextValue\n *\n * @property {string}                    text         Text.\n * @property {Array<RichTextFormatList>} formats      Formats.\n * @property {Array<RichTextFormat>}     replacements Replacements.\n * @property {number|undefined}          start        Selection start.\n * @property {number|undefined}          end          Selection end.\n */\n\nfunction createEmptyValue() {\n\treturn {\n\t\tformats: [],\n\t\treplacements: [],\n\t\ttext: '',\n\t};\n}\n\nfunction toFormat( { type, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( richTextStore ).getFormatTypeForClassName(\n\t\t\tattributes.class\n\t\t);\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `\n\t\t\t\t.replace( ` ${ formatType.className } `, ' ' )\n\t\t\t\t.trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType =\n\t\t\tselect( richTextStore ).getFormatTypeForBareElement( type );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type, attributes } : { type };\n\t}\n\n\tif (\n\t\tformatType.__experimentalCreatePrepareEditableTree &&\n\t\t! formatType.__experimentalCreateOnChangeEditableValue\n\t) {\n\t\treturn null;\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { type: formatType.name };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\tconst _attributes = { ...attributes };\n\n\tfor ( const key in formatType.attributes ) {\n\t\tconst name = formatType.attributes[ key ];\n\n\t\tregisteredAttributes[ key ] = _attributes[ name ];\n\n\t\tif ( formatType.__unstableFilterAttributeValue ) {\n\t\t\tregisteredAttributes[ key ] =\n\t\t\t\tformatType.__unstableFilterAttributeValue(\n\t\t\t\t\tkey,\n\t\t\t\t\tregisteredAttributes[ key ]\n\t\t\t\t);\n\t\t}\n\n\t\t// delete the attribute and what's left is considered\n\t\t// to be unregistered.\n\t\tdelete _attributes[ name ];\n\n\t\tif ( typeof registeredAttributes[ key ] === 'undefined' ) {\n\t\t\tdelete registeredAttributes[ key ];\n\t\t}\n\t}\n\n\tfor ( const name in _attributes ) {\n\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t}\n\n\treturn {\n\t\ttype: formatType.name,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. If\n * `multilineTag` is provided, any content of direct children whose type matches\n * `multilineTag` will be separated by two newlines. The optional functions can\n * be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                          Optional named arguments.\n * @param {Element} [$1.element]                  Element to create value from.\n * @param {string}  [$1.text]                     Text to create value from.\n * @param {string}  [$1.html]                     HTML to create value from.\n * @param {Range}   [$1.range]                    Range to create value from.\n * @param {string}  [$1.multilineTag]             Multiline tag if the structure is\n *                                                multiline.\n * @param {Array}   [$1.multilineWrapperTags]     Tags where lines can be found if\n *                                                nesting is possible.\n * @param {boolean} [$1.preserveWhiteSpace]       Whether or not to collapse white\n *                                                space characters.\n * @param {boolean} [$1.__unstableIsEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\t__unstableIsEditableTree: isEditableTree,\n\tpreserveWhiteSpace,\n} = {} ) {\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\treplacements: Array( text.length ),\n\t\t\ttext,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\t// It does not matter which document this is, we're just using it to\n\t\t// parse.\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\tif ( ! multilineTag ) {\n\t\treturn createFromElement( {\n\t\t\telement,\n\t\t\trange,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\t}\n\n\treturn createFromMultilineElement( {\n\t\telement,\n\t\trange,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tisEditableTree,\n\t\tpreserveWhiteSpace,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * @param {string} string\n */\nfunction collapseWhiteSpace( string ) {\n\treturn string.replace( /[\\n\\r\\t]+/g, ' ' );\n}\n\n/**\n * Removes reserved characters used by rich-text (zero width non breaking spaces added by `toTree` and object replacement characters).\n *\n * @param {string} string\n */\nexport function removeReservedCharacters( string ) {\n\t// with the global flag, note that we should create a new regex each time OR reset lastIndex state.\n\treturn string.replace(\n\t\tnew RegExp( `[${ ZWNBSP }${ OBJECT_REPLACEMENT_CHARACTER }]`, 'gu' ),\n\t\t''\n\t);\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                        Named argements.\n * @param {Element} [$1.element]              Element to create value from.\n * @param {Range}   [$1.range]                Range to create value from.\n * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\n *                                            multiline.\n * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\n *                                            nesting is possible.\n * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white\n *                                            space characters.\n * @param {Array}   [$1.currentWrapperTags]\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tisEditableTree,\n\tpreserveWhiteSpace,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst type = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tlet filter = removeReservedCharacters;\n\n\t\t\tif ( ! preserveWhiteSpace ) {\n\t\t\t\tfilter = ( string ) =>\n\t\t\t\t\tremoveReservedCharacters( collapseWhiteSpace( string ) );\n\t\t\t}\n\n\t\t\tconst text = filter( node.nodeValue );\n\t\t\trange = filterRange( node, range, filter );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\taccumulator.replacements.length += text.length;\n\t\t\taccumulator.text += text;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== node.ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tisEditableTree &&\n\t\t\t// Ignore any placeholders.\n\t\t\t( node.getAttribute( 'data-rich-text-placeholder' ) ||\n\t\t\t\t// Ignore any line breaks that are not inserted by us.\n\t\t\t\t( type === 'br' &&\n\t\t\t\t\t! node.getAttribute( 'data-rich-text-line-break' ) ) )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( type === 'script' ) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-script':\n\t\t\t\t\t\t\t\tnode.getAttribute( 'data-rich-text-script' ) ||\n\t\t\t\t\t\t\t\tencodeURIComponent( node.innerHTML ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( type === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, create( { text: '\\n' } ) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst format = toFormat( {\n\t\t\ttype,\n\t\t\tattributes: getAttributes( { element: node } ),\n\t\t} );\n\n\t\tif (\n\t\t\tmultilineWrapperTags &&\n\t\t\tmultilineWrapperTags.indexOf( type ) !== -1\n\t\t) {\n\t\t\tconst value = createFromMultilineElement( {\n\t\t\t\telement: node,\n\t\t\t\trange,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t\tcurrentWrapperTags: [ ...currentWrapperTags, format ],\n\t\t\t\tisEditableTree,\n\t\t\t\tpreserveWhiteSpace,\n\t\t\t} );\n\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\tif ( ! format ) {\n\t\t\tmergePair( accumulator, value );\n\t\t} else if ( value.text.length === 0 ) {\n\t\t\tif ( format.attributes ) {\n\t\t\t\tmergePair( accumulator, {\n\t\t\t\t\tformats: [ , ],\n\t\t\t\t\treplacements: [ format ],\n\t\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\t// Indices should share a reference to the same formats array.\n\t\t\t// Only create a new reference if `formats` changes.\n\t\t\tfunction mergeFormats( formats ) {\n\t\t\t\tif ( mergeFormats.formats === formats ) {\n\t\t\t\t\treturn mergeFormats.newFormats;\n\t\t\t\t}\n\n\t\t\t\tconst newFormats = formats\n\t\t\t\t\t? [ format, ...formats ]\n\t\t\t\t\t: [ format ];\n\n\t\t\t\tmergeFormats.formats = formats;\n\t\t\t\tmergeFormats.newFormats = newFormats;\n\n\t\t\t\treturn newFormats;\n\t\t\t}\n\n\t\t\t// Since the formats parameter can be `undefined`, preset\n\t\t\t// `mergeFormats` with a new reference.\n\t\t\tmergeFormats.newFormats = [ format ];\n\n\t\t\tmergePair( accumulator, {\n\t\t\t\t...value,\n\t\t\t\tformats: Array.from( value.formats, mergeFormats ),\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Creates a rich text value from a DOM element and range that should be\n * multiline.\n *\n * @param {Object}  $1                        Named argements.\n * @param {Element} [$1.element]              Element to create value from.\n * @param {Range}   [$1.range]                Range to create value from.\n * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\n *                                            multiline.\n * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\n *                                            nesting is possible.\n * @param {Array}   [$1.currentWrapperTags]   Whether to prepend a line\n *                                            separator.\n * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white\n *                                            space characters.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromMultilineElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tisEditableTree,\n\tpreserveWhiteSpace,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element || ! element.hasChildNodes() ) {\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.children.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.children[ index ];\n\n\t\tif ( node.nodeName.toLowerCase() !== multilineTag ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tcurrentWrapperTags,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\t// Multiline value text should be separated by a line separator.\n\t\tif ( index !== 0 || currentWrapperTags.length > 0 ) {\n\t\t\tmergePair( accumulator, {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements:\n\t\t\t\t\tcurrentWrapperTags.length > 0\n\t\t\t\t\t\t? [ currentWrapperTags ]\n\t\t\t\t\t\t: [ , ],\n\t\t\t\ttext: LINE_SEPARATOR,\n\t\t\t} );\n\t\t}\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\t\tmergePair( accumulator, value );\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named argements.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes( { element } ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( name.indexOf( 'data-rich-text-' ) === 0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst safeName = /^on/i.test( name )\n\t\t\t? 'data-disable-rich-text-' + name\n\t\t\t: name;\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ safeName ] = value;\n\t}\n\n\treturn accumulator;\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\nimport { create } from './create';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Concats a pair of rich text values. Not that this mutates `a` and does NOT\n * normalise formats!\n *\n * @param {Object} a Value to mutate.\n * @param {Object} b Value to add read from.\n *\n * @return {Object} `a`, mutated.\n */\nexport function mergePair( a, b ) {\n\ta.formats = a.formats.concat( b.formats );\n\ta.replacements = a.replacements.concat( b.replacements );\n\ta.text += b.text;\n\n\treturn a;\n}\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...RichTextValue} values Objects to combine.\n *\n * @return {RichTextValue} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( mergePair, create() ) );\n}\n","/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormatList} RichTextFormatList */\n\n/**\n * Gets the all format objects at the start of the selection.\n *\n * @param {RichTextValue} value                Value to inspect.\n * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no\n *                                             active formats.\n *\n * @return {RichTextFormatList} Active format objects.\n */\nexport function getActiveFormats(\n\t{ formats, start, end, activeFormats },\n\tEMPTY_ACTIVE_FORMATS = []\n) {\n\tif ( start === undefined ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tif ( start === end ) {\n\t\t// For a collapsed caret, it is possible to override the active formats.\n\t\tif ( activeFormats ) {\n\t\t\treturn activeFormats;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\n\t\t// By default, select the lowest amount of formats possible (which means\n\t\t// the caret is positioned outside the format boundary). The user can\n\t\t// then use arrow keys to define `activeFormats`.\n\t\tif ( formatsBefore.length < formatsAfter.length ) {\n\t\t\treturn formatsBefore;\n\t\t}\n\n\t\treturn formatsAfter;\n\t}\n\n\treturn formats[ start ] || EMPTY_ACTIVE_FORMATS;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {RichTextValue} value      Value to inspect.\n * @param {string}        formatType Format type to look for.\n *\n * @return {RichTextFormat|undefined} Active format object of the specified\n *                                    type, or undefined.\n */\nexport function getActiveFormat( value, formatType ) {\n\treturn find( getActiveFormats( value ), { type: formatType } );\n}\n","/**\n * Internal dependencies\n */\n\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the active object, if there is any.\n *\n * @param {RichTextValue} value Value to inspect.\n *\n * @return {RichTextFormat|void} Active object, or undefined.\n */\nexport function getActiveObject( { start, end, replacements, text } ) {\n\tif ( start + 1 !== end || text[ start ] !== OBJECT_REPLACEMENT_CHARACTER ) {\n\t\treturn;\n\t}\n\n\treturn replacements[ start ];\n}\n","/**\n * Internal dependencies\n */\nimport {\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tLINE_SEPARATOR,\n} from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text\n\t\t.replace( new RegExp( OBJECT_REPLACEMENT_CHARACTER, 'g' ), '' )\n\t\t.replace( new RegExp( LINE_SEPARATOR, 'g' ), '\\n' );\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Gets the currently selected line index, or the first line index if the\n * selection spans over multiple items.\n *\n * @param {RichTextValue} value      Value to get the line index from.\n * @param {boolean}       startIndex Optional index that should be contained by\n *                                   the line. Defaults to the selection start\n *                                   of the value.\n *\n * @return {number|void} The line index. Undefined if not found.\n */\nexport function getLineIndex( { start, text }, startIndex = start ) {\n\tlet index = startIndex;\n\n\twhile ( index-- ) {\n\t\tif ( text[ index ] === LINE_SEPARATOR ) {\n\t\t\treturn index;\n\t\t}\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Whether or not the root list is selected.\n *\n * @param {RichTextValue} value The value to check.\n *\n * @return {boolean} True if the root list or nothing is selected, false if an\n *                   inner list is selected.\n */\nexport function isListRootSelected( value ) {\n\tconst { replacements, start } = value;\n\tconst lineIndex = getLineIndex( value, start );\n\tconst replacement = replacements[ lineIndex ];\n\n\treturn ! replacement || replacement.length < 1;\n}\n","/**\n * Internal dependencies\n */\n\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Whether or not the selected list has the given tag name.\n *\n * @param {RichTextValue} value    The value to check.\n * @param {string}        type     The tag name the list should have.\n * @param {string}        rootType The current root tag name, to compare with in\n *                                 case nothing is selected.\n *\n * @return {boolean} True if the current list type matches `type`, false if not.\n */\nexport function isActiveListType( value, type, rootType ) {\n\tconst { replacements, start } = value;\n\tconst lineIndex = getLineIndex( value, start );\n\tconst replacement = replacements[ lineIndex ];\n\n\tif ( ! replacement || replacement.length === 0 ) {\n\t\treturn type === rootType;\n\t}\n\n\tconst lastFormat = replacement[ replacement.length - 1 ];\n\n\treturn lastFormat.type === type;\n}\n","/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param {RichTextValue} value The rich text value to check.\n *\n * @return {boolean|undefined} True if the selection is collapsed, false if not,\n *                             undefined if there is no selection.\n */\nexport function isCollapsed( { start, end } ) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n","/**\n * Internal dependencies\n */\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n\n/**\n * Check if the current collapsed selection is on an empty line in case of a\n * multiline value.\n *\n * @param {RichTextValue} value Value te check.\n *\n * @return {boolean} True if the line is empty, false if not.\n */\nexport function isEmptyLine( { text, start, end } ) {\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\tif ( text.length === 0 ) {\n\t\treturn true;\n\t}\n\n\tif ( start === 0 && text.slice( 0, 1 ) === LINE_SEPARATOR ) {\n\t\treturn true;\n\t}\n\n\tif ( start === text.length && text.slice( -1 ) === LINE_SEPARATOR ) {\n\t\treturn true;\n\t}\n\n\treturn (\n\t\ttext.slice( start - 1, end + 1 ) ===\n\t\t`${ LINE_SEPARATOR }${ LINE_SEPARATOR }`\n\t);\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array<RichTextValue>} values      An array of values to join.\n * @param {string|RichTextValue} [separator] Separator string or value.\n *\n * @return {RichTextValue} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats(\n\t\tvalues.reduce( ( accumlator, { formats, replacements, text } ) => ( {\n\t\t\tformats: accumlator.formats.concat( separator.formats, formats ),\n\t\t\treplacements: accumlator.replacements.concat(\n\t\t\t\tseparator.replacements,\n\t\t\t\treplacements\n\t\t\t),\n\t\t\ttext: accumlator.text + separator.text + text,\n\t\t} ) )\n\t);\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n/**\n * @typedef {Object} WPFormat\n *\n * @property {string}   name        A string identifying the format. Must be\n *                                  unique across all registered formats.\n * @property {string}   tagName     The HTML tag this format will wrap the\n *                                  selection with.\n * @property {string}   [className] A class to match the format.\n * @property {string}   title       Name of the format.\n * @property {Function} edit        Should return a component for the user to\n *                                  interact with the new registered format.\n */\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string}   name     Format name.\n * @param {WPFormat} settings Format settings.\n *\n * @return {WPFormat|undefined} The format, if it has been successfully\n *                              registered; otherwise `undefined`.\n */\nexport function registerFormatType( name, settings ) {\n\tsettings = {\n\t\tname,\n\t\t...settings,\n\t};\n\n\tif ( typeof settings.name !== 'string' ) {\n\t\twindow.console.error( 'Format names must be strings.' );\n\t\treturn;\n\t}\n\n\tif ( ! /^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( select( richTextStore ).getFormatType( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format \"' + settings.name + '\" is already registered.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.tagName !== 'string' || settings.tagName === '' ) {\n\t\twindow.console.error( 'Format tag names must be a string.' );\n\t\treturn;\n\t}\n\n\tif (\n\t\t( typeof settings.className !== 'string' ||\n\t\t\tsettings.className === '' ) &&\n\t\tsettings.className !== null\n\t) {\n\t\twindow.console.error(\n\t\t\t'Format class names must be a string, or null to handle bare elements.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[_a-zA-Z]+[a-zA-Z0-9-]*$/.test( settings.className ) ) {\n\t\twindow.console.error(\n\t\t\t'A class name must begin with a letter, followed by any number of hyphens, letters, or numbers.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( settings.className === null ) {\n\t\tconst formatTypeForBareElement = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForBareElement( settings.tagName );\n\n\t\tif ( formatTypeForBareElement ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForBareElement.name }\" is already registered to handle bare tag name \"${ settings.tagName }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tconst formatTypeForClassName = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForClassName( settings.className );\n\n\t\tif ( formatTypeForClassName ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForClassName.name }\" is already registered to handle class name \"${ settings.className }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( ! ( 'title' in settings ) || settings.title === '' ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" must have a title.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( 'keywords' in settings && settings.keywords.length > 3 ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' +\n\t\t\t\tsettings.name +\n\t\t\t\t'\" can have a maximum of 3 keywords.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.title !== 'string' ) {\n\t\twindow.console.error( 'Format titles must be strings.' );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).addFormatTypes( settings );\n\n\treturn settings;\n}\n","/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function removeFormat(\n\tvalue,\n\tformatType,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = find( newFormats[ startIndex ], { type: formatType } );\n\n\t\tif ( format ) {\n\t\t\twhile ( find( newFormats[ startIndex ], format ) ) {\n\t\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile ( find( newFormats[ endIndex ], format ) ) {\n\t\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\tactiveFormats: reject( activeFormats, { type: formatType } ),\n\t} );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter(\n\t\t( { type } ) => type !== formatType\n\t);\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {RichTextValue}        value         Value to modify.\n * @param {RichTextValue|string} valueToInsert Value to insert.\n * @param {number}               [startIndex]  Start index.\n * @param {number}               [endIndex]    End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nexport function insert(\n\tvalue,\n\tvalueToInsert,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\treplacements: replacements\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat(\n\t\t\t\tvalueToInsert.replacements,\n\t\t\t\treplacements.slice( endIndex )\n\t\t\t),\n\t\ttext:\n\t\t\ttext.slice( 0, startIndex ) +\n\t\t\tvalueToInsert.text +\n\t\t\ttext.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {RichTextValue}   value       The value to modify.\n * @param {RegExp|string}   pattern     A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {RichTextValue} A new value with replacements applied.\n */\nexport function replace(\n\t{ formats, replacements, text, start, end },\n\tpattern,\n\treplacement\n) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\t\tlet newReplacements;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewReplacements = newText.replacements;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\t\t\tnewReplacements = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats\n\t\t\t.slice( 0, offset )\n\t\t\t.concat( newFormats, formats.slice( offset + match.length ) );\n\t\treplacements = replacements\n\t\t\t.slice( 0, offset )\n\t\t\t.concat(\n\t\t\t\tnewReplacements,\n\t\t\t\treplacements.slice( offset + match.length )\n\t\t\t);\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, replacements, text, start, end } );\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Insert a line break character into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nexport function insertLineSeparator(\n\tvalue,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst beforeText = value.text.slice( 0, startIndex );\n\tconst previousLineSeparatorIndex = beforeText.lastIndexOf( LINE_SEPARATOR );\n\tconst previousLineSeparatorFormats =\n\t\tvalue.replacements[ previousLineSeparatorIndex ];\n\tlet replacements = [ , ];\n\n\tif ( previousLineSeparatorFormats ) {\n\t\treplacements = [ previousLineSeparatorFormats ];\n\t}\n\n\tconst valueToInsert = {\n\t\tformats: [ , ],\n\t\treplacements,\n\t\ttext: LINE_SEPARATOR,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { isCollapsed } from './is-collapsed';\nimport { remove } from './remove';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Removes a line separator character, if existing, from a Rich Text value at\n * the current indices. If no line separator exists on the indices it will\n * return undefined.\n *\n * @param {RichTextValue} value    Value to modify.\n * @param {boolean}       backward Indicates if are removing from the start\n *                                 index or the end index.\n *\n * @return {RichTextValue|undefined} A new value with the line separator\n *                                   removed. Or undefined if no line separator\n *                                   is found on the position.\n */\nexport function removeLineSeparator( value, backward = true ) {\n\tconst { replacements, text, start, end } = value;\n\tconst collapsed = isCollapsed( value );\n\tlet index = start - 1;\n\tlet removeStart = collapsed ? start - 1 : start;\n\tlet removeEnd = end;\n\tif ( ! backward ) {\n\t\tindex = end;\n\t\tremoveStart = start;\n\t\tremoveEnd = collapsed ? end + 1 : end;\n\t}\n\n\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\treturn;\n\t}\n\n\tlet newValue;\n\t// If the line separator that is about te be removed\n\t// contains wrappers, remove the wrappers first.\n\tif ( collapsed && replacements[ index ] && replacements[ index ].length ) {\n\t\tconst newReplacements = replacements.slice();\n\n\t\tnewReplacements[ index ] = replacements[ index ].slice( 0, -1 );\n\t\tnewValue = {\n\t\t\t...value,\n\t\t\treplacements: newReplacements,\n\t\t};\n\t} else {\n\t\tnewValue = remove( value, removeStart, removeEnd );\n\t}\n\treturn newValue;\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue}  value          Value to modify.\n * @param {RichTextFormat} formatToInsert Format to insert as object.\n * @param {number}         [startIndex]   Start index.\n * @param {number}         [endIndex]     End index.\n *\n * @return {RichTextValue} A new value with the object inserted.\n */\nexport function insertObject( value, formatToInsert, startIndex, endIndex ) {\n\tconst valueToInsert = {\n\t\tformats: [ , ],\n\t\treplacements: [ formatToInsert ],\n\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new extracted value.\n */\nexport function slice( value, startIndex = value.start, endIndex = value.end ) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { ...value };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\treplacements: replacements.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n","/**\n * Internal dependencies\n */\n\nimport { replace } from './replace';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>|undefined} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [\n\t\t// Ensure newlines are trimmed.\n\t\treplace( before, /\\u2028+$/, '' ),\n\t\treplace( after, /^\\u2028+/, '' ),\n\t];\n}\n","/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\tlastCharacter === LINE_SEPARATOR ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = (\n\t\t\t\t\treplacements[ i ] || []\n\t\t\t\t).reduce(\n\t\t\t\t\t( accumulator, format ) => {\n\t\t\t\t\t\taccumulator.push( format, multilineFormat );\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t},\n\t\t\t\t\t[ multilineFormat ]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [\n\t\t\t\t\t...lastSeparatorFormats,\n\t\t\t\t\t...( characterFormats || [] ),\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( shouldInsertPadding && character === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tappend( getParent( node ), ZWNBSP );\n\t\t}\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t) &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, attributes, unregisteredAttributes } = format;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree &&\n\t\t\t\t\tcharacter !== LINE_SEPARATOR &&\n\t\t\t\t\tformat === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tif ( ! isEditableTree && replacements[ i ]?.type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\treplacements[ i ].attributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacements[ i ],\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection. The placeholder is also not editable after\n\t\t\t\t\t\t// all.\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} Format type.\n */\nexport function getFormatType( name ) {\n\treturn select( richTextStore ).getFormatType( name );\n}\n","/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( node ) {\n\treturn node.nodeType === node.TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n\tdoc = document,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new instance of a DOM tree upon which RichText operations can be\n\t * applied.\n\t *\n\t * Note: The current implementation will return a shared reference, reset on\n\t * each call to `createEmpty`. Therefore, you should not hold a reference to\n\t * the value to operate upon asynchronously, as it may have unexpected results.\n\t *\n\t * @return {Object} RichText tree.\n\t */\n\tconst createEmpty = () => createElement( doc, '' );\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {string}        [$1.multilineTag]        Multiline tag.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t\tdoc: current.ownerDocument,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === currentChild.TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\n/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range} a First range object to test.\n * @param {Range} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nfunction isRangeEqual( a, b ) {\n\treturn (\n\t\ta.startContainer === b.startContainer &&\n\t\ta.startOffset === b.startOffset &&\n\t\ta.endContainer === b.endContainer &&\n\t\ta.endOffset === b.endOffset\n\t);\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst { ownerDocument } = current;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state.\n\tif ( activeElement !== ownerDocument.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement instanceof defaultView.HTMLElement ) {\n\t\t\tactiveElement.focus();\n\t\t}\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"escapeHtml\"];","/**\n * WordPress dependencies\n */\n\nimport {\n\tescapeEditableHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Create an HTML string from a Rich Text value. If a `multilineTag` is\n * provided, text separated by a line separator will be wrapped in it.\n *\n * @param {Object}        $1                      Named argements.\n * @param {RichTextValue} $1.value                Rich text value.\n * @param {string}        [$1.multilineTag]       Multiline tag.\n * @param {boolean}       [$1.preserveWhiteSpace] Whether or not to use newline\n *                                                characters for line breaks.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( { value, multilineTag, preserveWhiteSpace } ) {\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tpreserveWhiteSpace,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty() {\n\treturn {};\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute(\n\t\t\tattributes[ key ]\n\t\t) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML(\n\t\tchildren\n\t) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children\n\t\t.map( ( child ) => {\n\t\t\tif ( child.html !== undefined ) {\n\t\t\t\treturn child.html;\n\t\t\t}\n\n\t\t\treturn child.text === undefined\n\t\t\t\t? createElementHTML( child )\n\t\t\t\t: escapeEditableHTML( child.text );\n\t\t} )\n\t\t.join( '' );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"a11y\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"i18n\"];","/**\n * WordPress dependencies\n */\n\nimport { speak } from '@wordpress/a11y';\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\n\nimport { getActiveFormat } from './get-active-format';\nimport { removeFormat } from './remove-format';\nimport { applyFormat } from './apply-format';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {RichTextValue}  value  Value to modify.\n * @param {RichTextFormat} format Format to apply or remove.\n *\n * @return {RichTextValue} A new value with the format applied or removed.\n */\nexport function toggleFormat( value, format ) {\n\tif ( getActiveFormat( value, format.type ) ) {\n\t\t// For screen readers, will announce if formatting control is disabled.\n\t\tif ( format.title ) {\n\t\t\t// translators: %s: title of the formatting control\n\t\t\tspeak( sprintf( __( '%s removed.' ), format.title ), 'assertive' );\n\t\t}\n\t\treturn removeFormat( value, format.type );\n\t}\n\t// For screen readers, will announce if formatting control is enabled.\n\tif ( format.title ) {\n\t\t// translators: %s: title of the formatting control\n\t\tspeak( sprintf( __( '%s applied.' ), format.title ), 'assertive' );\n\t}\n\treturn applyFormat( value, format );\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} The previous format value, if it has\n *                                        been successfully unregistered;\n *                                        otherwise `undefined`.\n */\nexport function unregisterFormatType( name ) {\n\tconst oldFormat = select( richTextStore ).getFormatType( name );\n\n\tif ( ! oldFormat ) {\n\t\twindow.console.error( `Format ${ name } is not registered.` );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).removeFormatTypes( name );\n\n\treturn oldFormat;\n}\n","/**\n * Internal dependencies\n */\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Checks if the selected list item can be indented.\n *\n * @param {RichTextValue} value Value to check.\n *\n * @return {boolean} Whether or not the selected list item can be indented.\n */\nexport function canIndentListItems( value ) {\n\tconst lineIndex = getLineIndex( value );\n\n\t// There is only one line, so the line cannot be indented.\n\tif ( lineIndex === undefined ) {\n\t\treturn false;\n\t}\n\n\tconst { replacements } = value;\n\tconst previousLineIndex = getLineIndex( value, lineIndex );\n\tconst formatsAtLineIndex = replacements[ lineIndex ] || [];\n\tconst formatsAtPreviousLineIndex = replacements[ previousLineIndex ] || [];\n\n\t// If the indentation of the current line is greater than previous line,\n\t// then the line cannot be furter indented.\n\treturn formatsAtLineIndex.length <= formatsAtPreviousLineIndex.length;\n}\n","/**\n * Internal dependencies\n */\n\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Checks if the selected list item can be outdented.\n *\n * @param {RichTextValue} value Value to check.\n *\n * @return {boolean} Whether or not the selected list item can be outdented.\n */\nexport function canOutdentListItems( value ) {\n\tconst { replacements, start } = value;\n\tconst startingLineIndex = getLineIndex( value, start );\n\treturn replacements[ startingLineIndex ] !== undefined;\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { canIndentListItems } from './can-indent-list-items';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the line index of the first previous list item with higher indentation.\n *\n * @param {RichTextValue} value     Value to search.\n * @param {number}        lineIndex Line index of the list item to compare\n *                                  with.\n *\n * @return {number|void} The line index.\n */\nfunction getTargetLevelLineIndex( { text, replacements }, lineIndex ) {\n\tconst startFormats = replacements[ lineIndex ] || [];\n\n\tlet index = lineIndex;\n\n\twhile ( index-- >= 0 ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\t// Return the first line index that is one level higher. If the level is\n\t\t// lower or equal, there is no result.\n\t\tif ( formatsAtIndex.length === startFormats.length + 1 ) {\n\t\t\treturn index;\n\t\t} else if ( formatsAtIndex.length <= startFormats.length ) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/**\n * Indents any selected list items if possible.\n *\n * @param {RichTextValue}  value      Value to change.\n * @param {RichTextFormat} rootFormat Root format.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function indentListItems( value, rootFormat ) {\n\tif ( ! canIndentListItems( value ) ) {\n\t\treturn value;\n\t}\n\n\tconst lineIndex = getLineIndex( value );\n\tconst previousLineIndex = getLineIndex( value, lineIndex );\n\tconst { text, replacements, end } = value;\n\tconst newFormats = replacements.slice();\n\tconst targetLevelLineIndex = getTargetLevelLineIndex( value, lineIndex );\n\n\tfor ( let index = lineIndex; index < end; index++ ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get the previous list, and if there's a child list, take over the\n\t\t// formats. If not, duplicate the last level and create a new level.\n\t\tif ( targetLevelLineIndex ) {\n\t\t\tconst targetFormats = replacements[ targetLevelLineIndex ] || [];\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length - 1 )\n\t\t\t);\n\t\t} else {\n\t\t\tconst targetFormats = replacements[ previousLineIndex ] || [];\n\t\t\tconst lastformat =\n\t\t\t\ttargetFormats[ targetFormats.length - 1 ] || rootFormat;\n\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t[ lastformat ],\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length )\n\t\t\t);\n\t\t}\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newFormats,\n\t};\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Gets the index of the first parent list. To get the parent list formats, we\n * go through every list item until we find one with exactly one format type\n * less.\n *\n * @param {RichTextValue} value     Value to search.\n * @param {number}        lineIndex Line index of a child list item.\n *\n * @return {number|void} The parent list line index.\n */\nexport function getParentLineIndex( { text, replacements }, lineIndex ) {\n\tconst startFormats = replacements[ lineIndex ] || [];\n\n\tlet index = lineIndex;\n\n\twhile ( index-- >= 0 ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\tif ( formatsAtIndex.length === startFormats.length - 1 ) {\n\t\t\treturn index;\n\t\t}\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { getParentLineIndex } from './get-parent-line-index';\nimport { getLastChildIndex } from './get-last-child-index';\nimport { canOutdentListItems } from './can-outdent-list-items';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Outdents any selected list items if possible.\n *\n * @param {RichTextValue} value Value to change.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function outdentListItems( value ) {\n\tif ( ! canOutdentListItems( value ) ) {\n\t\treturn value;\n\t}\n\n\tconst { text, replacements, start, end } = value;\n\tconst startingLineIndex = getLineIndex( value, start );\n\tconst newFormats = replacements.slice( 0 );\n\tconst parentFormats =\n\t\treplacements[ getParentLineIndex( value, startingLineIndex ) ] || [];\n\tconst endingLineIndex = getLineIndex( value, end );\n\tconst lastChildIndex = getLastChildIndex( value, endingLineIndex );\n\n\t// Outdent all list items from the starting line index until the last child\n\t// index of the ending list. All children of the ending list need to be\n\t// outdented, otherwise they'll be orphaned.\n\tfor ( let index = startingLineIndex; index <= lastChildIndex; index++ ) {\n\t\t// Skip indices that are not line separators.\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// In the case of level 0, the formats at the index are undefined.\n\t\tconst currentFormats = newFormats[ index ] || [];\n\n\t\t// Omit the indentation level where the selection starts.\n\t\tnewFormats[ index ] = parentFormats.concat(\n\t\t\tcurrentFormats.slice( parentFormats.length + 1 )\n\t\t);\n\n\t\tif ( newFormats[ index ].length === 0 ) {\n\t\t\tdelete newFormats[ index ];\n\t\t}\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newFormats,\n\t};\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Gets the line index of the last child in the list.\n *\n * @param {RichTextValue} value     Value to search.\n * @param {number}        lineIndex Line index of a list item in the list.\n *\n * @return {number} The index of the last child.\n */\nexport function getLastChildIndex( { text, replacements }, lineIndex ) {\n\tconst lineFormats = replacements[ lineIndex ] || [];\n\t// Use the given line index in case there are no next children.\n\tlet childIndex = lineIndex;\n\n\t// `lineIndex` could be `undefined` if it's the first line.\n\tfor ( let index = lineIndex || 0; index < text.length; index++ ) {\n\t\t// We're only interested in line indices.\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\t// If the amout of formats is equal or more, store it, then return the\n\t\t// last one if the amount of formats is less.\n\t\tif ( formatsAtIndex.length >= lineFormats.length ) {\n\t\t\tchildIndex = index;\n\t\t} else {\n\t\t\treturn childIndex;\n\t\t}\n\t}\n\n\t// If the end of the text is reached, return the last child index.\n\treturn childIndex;\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { getParentLineIndex } from './get-parent-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Changes the list type of the selected indented list, if any. Looks at the\n * currently selected list item and takes the parent list, then changes the list\n * type of this list. When multiple lines are selected, the parent lists are\n * takes and changed.\n *\n * @param {RichTextValue}  value     Value to change.\n * @param {RichTextFormat} newFormat The new list format object. Choose between\n *                                   `{ type: 'ol' }` and `{ type: 'ul' }`.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function changeListType( value, newFormat ) {\n\tconst { text, replacements, start, end } = value;\n\tconst startingLineIndex = getLineIndex( value, start );\n\tconst startLineFormats = replacements[ startingLineIndex ] || [];\n\tconst endLineFormats = replacements[ getLineIndex( value, end ) ] || [];\n\tconst startIndex = getParentLineIndex( value, startingLineIndex );\n\tconst newReplacements = replacements.slice();\n\tconst startCount = startLineFormats.length - 1;\n\tconst endCount = endLineFormats.length - 1;\n\n\tlet changed;\n\n\tfor ( let index = startIndex + 1 || 0; index < text.length; index++ ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( ( newReplacements[ index ] || [] ).length <= startCount ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( ! newReplacements[ index ] ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchanged = true;\n\t\tnewReplacements[ index ] = newReplacements[ index ].map(\n\t\t\t( format, i ) => {\n\t\t\t\treturn i < startCount || i > endCount ? format : newFormat;\n\t\t\t}\n\t\t);\n\t}\n\n\tif ( ! changed ) {\n\t\treturn value;\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newReplacements,\n\t};\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"element\"];","/**\n * WordPress dependencies\n */\nimport { useMemo } from '@wordpress/element';\n\n/**\n * Internal dependencies\n */\nimport { getActiveFormat } from '../get-active-format';\n\n/** @typedef {import('@wordpress/element').RefObject} RefObject */\n/** @typedef {import('../register-format-type').RichTextFormatType} RichTextFormatType */\n/** @typedef {import('../create').RichTextValue} RichTextValue */\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or the selection range if no format is active.\n * The returned value is meant to be used for positioning UI, e.g. by passing it\n * to the `Popover` component.\n *\n * @param {Object}                 $1          Named parameters.\n * @param {RefObject<HTMLElement>} $1.ref      React ref of the element\n *                                             containing  the editable content.\n * @param {RichTextValue}          $1.value    Value to check for selection.\n * @param {RichTextFormatType}     $1.settings The format type's settings.\n *\n * @return {Element|Range} The active element or selection range.\n */\nexport function useAnchorRef( { ref, value, settings = {} } ) {\n\tconst { tagName, className, name } = settings;\n\tconst activeFormat = name ? getActiveFormat( value, name ) : undefined;\n\n\treturn useMemo( () => {\n\t\tif ( ! ref.current ) return;\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\n\t\tif ( ! selection.rangeCount ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = selection.getRangeAt( 0 );\n\n\t\tif ( ! activeFormat ) {\n\t\t\treturn range;\n\t\t}\n\n\t\tlet element = range.startContainer;\n\n\t\t// If the caret is right before the element, select the next element.\n\t\telement = element.nextElementSibling || element;\n\n\t\twhile ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\t\telement = element.parentNode;\n\t\t}\n\n\t\treturn element.closest(\n\t\t\ttagName + ( className ? '.' + className : '' )\n\t\t);\n\t}, [ activeFormat, value.start, value.end, tagName, className ] );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"compose\"];","/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from '@wordpress/element';\n\n/*\n * Calculates and renders the format boundary style when the active formats\n * change.\n */\nexport function useBoundaryStyle( { record } ) {\n\tconst ref = useRef();\n\tconst { activeFormats = [] } = record.current;\n\tuseEffect( () => {\n\t\t// There's no need to recalculate the boundary styles if no formats are\n\t\t// active, because no boundary styles will be visible.\n\t\tif ( ! activeFormats || ! activeFormats.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst boundarySelector = '*[data-rich-text-format-boundary]';\n\t\tconst element = ref.current.querySelector( boundarySelector );\n\n\t\tif ( ! element ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst computedStyle = defaultView.getComputedStyle( element );\n\t\tconst newColor = computedStyle.color\n\t\t\t.replace( ')', ', 0.2)' )\n\t\t\t.replace( 'rgb', 'rgba' );\n\t\tconst selector = `.rich-text:focus ${ boundarySelector }`;\n\t\tconst rule = `background-color: ${ newColor }`;\n\t\tconst style = `${ selector } {${ rule }}`;\n\t\tconst globalStyleId = 'rich-text-boundary-style';\n\n\t\tlet globalStyle = ownerDocument.getElementById( globalStyleId );\n\n\t\tif ( ! globalStyle ) {\n\t\t\tglobalStyle = ownerDocument.createElement( 'style' );\n\t\t\tglobalStyle.id = globalStyleId;\n\t\t\townerDocument.head.appendChild( globalStyle );\n\t\t}\n\n\t\tif ( globalStyle.innerHTML !== style ) {\n\t\t\tglobalStyle.innerHTML = style;\n\t\t}\n\t}, [ activeFormats ] );\n\treturn ref;\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { toHTMLString } from '../to-html-string';\nimport { isCollapsed } from '../is-collapsed';\nimport { slice } from '../slice';\nimport { getTextContent } from '../get-text-content';\n\nexport function useCopyHandler( props ) {\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onCopy( event ) {\n\t\t\tconst { record, multilineTag, preserveWhiteSpace } =\n\t\t\t\tpropsRef.current;\n\t\t\tif (\n\t\t\t\tisCollapsed( record.current ) ||\n\t\t\t\t! element.contains( element.ownerDocument.activeElement )\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedRecord = slice( record.current );\n\t\t\tconst plainText = getTextContent( selectedRecord );\n\t\t\tconst html = toHTMLString( {\n\t\t\t\tvalue: selectedRecord,\n\t\t\t\tmultilineTag,\n\t\t\t\tpreserveWhiteSpace,\n\t\t\t} );\n\t\t\tevent.clipboardData.setData( 'text/plain', plainText );\n\t\t\tevent.clipboardData.setData( 'text/html', html );\n\t\t\tevent.clipboardData.setData( 'rich-text', 'true' );\n\t\t\tevent.clipboardData.setData(\n\t\t\t\t'rich-text-multi-line-tag',\n\t\t\t\tmultilineTag || ''\n\t\t\t);\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\telement.addEventListener( 'copy', onCopy );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'copy', onCopy );\n\t\t};\n\t}, [] );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"keycodes\"];","/**\n * WordPress dependencies\n */\nimport { useRef, useReducer } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\nimport { LEFT, RIGHT } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { isCollapsed } from '../is-collapsed';\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nexport function useFormatBoundaries( props ) {\n\tconst [ , forceRender ] = useReducer( () => ( {} ) );\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onKeyDown( event ) {\n\t\t\tconst { keyCode, shiftKey, altKey, metaKey, ctrlKey } = event;\n\n\t\t\tif (\n\t\t\t\t// Only override left and right keys without modifiers pressed.\n\t\t\t\tshiftKey ||\n\t\t\t\taltKey ||\n\t\t\t\tmetaKey ||\n\t\t\t\tctrlKey ||\n\t\t\t\t( keyCode !== LEFT && keyCode !== RIGHT )\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { record, applyRecord } = propsRef.current;\n\t\t\tconst {\n\t\t\t\ttext,\n\t\t\t\tformats,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tactiveFormats: currentActiveFormats = [],\n\t\t\t} = record.current;\n\t\t\tconst collapsed = isCollapsed( record.current );\n\t\t\tconst { ownerDocument } = element;\n\t\t\tconst { defaultView } = ownerDocument;\n\t\t\t// To do: ideally, we should look at visual position instead.\n\t\t\tconst { direction } = defaultView.getComputedStyle( element );\n\t\t\tconst reverseKey = direction === 'rtl' ? RIGHT : LEFT;\n\t\t\tconst isReverse = event.keyCode === reverseKey;\n\n\t\t\t// If the selection is collapsed and at the very start, do nothing if\n\t\t\t// navigating backward.\n\t\t\t// If the selection is collapsed and at the very end, do nothing if\n\t\t\t// navigating forward.\n\t\t\tif ( collapsed && currentActiveFormats.length === 0 ) {\n\t\t\t\tif ( start === 0 && isReverse ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( end === text.length && ! isReverse ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the selection is not collapsed, let the browser handle collapsing\n\t\t\t// the selection for now. Later we could expand this logic to set\n\t\t\t// boundary positions if needed.\n\t\t\tif ( ! collapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\t\t\tconst destination = isReverse ? formatsBefore : formatsAfter;\n\t\t\tconst isIncreasing = currentActiveFormats.every(\n\t\t\t\t( format, index ) => format === destination[ index ]\n\t\t\t);\n\n\t\t\tlet newActiveFormatsLength = currentActiveFormats.length;\n\n\t\t\tif ( ! isIncreasing ) {\n\t\t\t\tnewActiveFormatsLength--;\n\t\t\t} else if ( newActiveFormatsLength < destination.length ) {\n\t\t\t\tnewActiveFormatsLength++;\n\t\t\t}\n\n\t\t\tif ( newActiveFormatsLength === currentActiveFormats.length ) {\n\t\t\t\trecord.current._newActiveFormats = destination;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst origin = isReverse ? formatsAfter : formatsBefore;\n\t\t\tconst source = isIncreasing ? destination : origin;\n\t\t\tconst newActiveFormats = source.slice( 0, newActiveFormatsLength );\n\t\t\tconst newValue = {\n\t\t\t\t...record.current,\n\t\t\t\tactiveFormats: newActiveFormats,\n\t\t\t};\n\t\t\trecord.current = newValue;\n\t\t\tapplyRecord( newValue );\n\t\t\tforceRender();\n\t\t}\n\n\t\telement.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\nimport { SPACE } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { isCollapsed } from '../is-collapsed';\nimport { LINE_SEPARATOR } from '../special-characters';\nimport { indentListItems } from '../indent-list-items';\n\nexport function useIndentListItemOnSpace( props ) {\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onKeyDown( event ) {\n\t\t\tconst { keyCode, shiftKey, altKey, metaKey, ctrlKey } = event;\n\t\t\tconst { multilineTag, createRecord, handleChange } =\n\t\t\t\tpropsRef.current;\n\n\t\t\tif (\n\t\t\t\t// Only override when no modifiers are pressed.\n\t\t\t\tshiftKey ||\n\t\t\t\taltKey ||\n\t\t\t\tmetaKey ||\n\t\t\t\tctrlKey ||\n\t\t\t\tkeyCode !== SPACE ||\n\t\t\t\tmultilineTag !== 'li'\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentValue = createRecord();\n\n\t\t\tif ( ! isCollapsed( currentValue ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { text, start } = currentValue;\n\t\t\tconst characterBefore = text[ start - 1 ];\n\n\t\t\t// The caret must be at the start of a line.\n\t\t\tif ( characterBefore && characterBefore !== LINE_SEPARATOR ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thandleChange(\n\t\t\t\tindentListItems( currentValue, {\n\t\t\t\t\ttype: element.tagName.toLowerCase(),\n\t\t\t\t} )\n\t\t\t);\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\telement.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { getActiveFormats } from '../get-active-formats';\nimport { updateFormats } from '../update-formats';\n\n/**\n * All inserting input types that would insert HTML into the DOM.\n *\n * @see https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes\n *\n * @type {Set}\n */\nconst INSERTION_INPUT_TYPES_TO_IGNORE = new Set( [\n\t'insertParagraph',\n\t'insertOrderedList',\n\t'insertUnorderedList',\n\t'insertHorizontalRule',\n\t'insertLink',\n] );\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\n/**\n * If the selection is set on the placeholder element, collapse the selection to\n * the start (before the placeholder).\n *\n * @param {Window} defaultView\n */\nfunction fixPlaceholderSelection( defaultView ) {\n\tconst selection = defaultView.getSelection();\n\tconst { anchorNode, anchorOffset } = selection;\n\n\tif ( anchorNode.nodeType !== anchorNode.ELEMENT_NODE ) {\n\t\treturn;\n\t}\n\n\tconst targetNode = anchorNode.childNodes[ anchorOffset ];\n\n\tif (\n\t\t! targetNode ||\n\t\ttargetNode.nodeType !== targetNode.ELEMENT_NODE ||\n\t\t! targetNode.getAttribute( 'data-rich-text-placeholder' )\n\t) {\n\t\treturn;\n\t}\n\n\tselection.collapseToStart();\n}\n\nexport function useInputAndSelection( props ) {\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\n\t\tlet isComposing = false;\n\t\tlet rafId;\n\n\t\tfunction onInput( event ) {\n\t\t\t// Do not trigger a change if characters are being composed.\n\t\t\t// Browsers  will usually emit a final `input` event when the\n\t\t\t// characters are composed.\n\t\t\t// As of December 2019, Safari doesn't support\n\t\t\t// nativeEvent.isComposing.\n\t\t\tif ( isComposing ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet inputType;\n\n\t\t\tif ( event ) {\n\t\t\t\tinputType = event.inputType;\n\t\t\t}\n\n\t\t\tconst { record, applyRecord, createRecord, handleChange } =\n\t\t\t\tpropsRef.current;\n\n\t\t\t// The browser formatted something or tried to insert HTML.\n\t\t\t// Overwrite it. It will be handled later by the format library if\n\t\t\t// needed.\n\t\t\tif (\n\t\t\t\tinputType &&\n\t\t\t\t( inputType.indexOf( 'format' ) === 0 ||\n\t\t\t\t\tINSERTION_INPUT_TYPES_TO_IGNORE.has( inputType ) )\n\t\t\t) {\n\t\t\t\tapplyRecord( record.current );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentValue = createRecord();\n\t\t\tconst { start, activeFormats: oldActiveFormats = [] } =\n\t\t\t\trecord.current;\n\n\t\t\t// Update the formats between the last and new caret position.\n\t\t\tconst change = updateFormats( {\n\t\t\t\tvalue: currentValue,\n\t\t\t\tstart,\n\t\t\t\tend: currentValue.start,\n\t\t\t\tformats: oldActiveFormats,\n\t\t\t} );\n\n\t\t\thandleChange( change );\n\t\t}\n\n\t\t/**\n\t\t * Syncs the selection to local state. A callback for the `selectionchange`\n\t\t * native events, `keyup`, `mouseup` and `touchend` synthetic events, and\n\t\t * animation frames after the `focus` event.\n\t\t *\n\t\t * @param {Event|DOMHighResTimeStamp} event\n\t\t */\n\t\tfunction handleSelectionChange( event ) {\n\t\t\tconst {\n\t\t\t\trecord,\n\t\t\t\tapplyRecord,\n\t\t\t\tcreateRecord,\n\t\t\t\tisSelected,\n\t\t\t\tonSelectionChange,\n\t\t\t} = propsRef.current;\n\n\t\t\t// Check if the implementor disabled editing. `contentEditable`\n\t\t\t// does disable input, but not text selection, so we must ignore\n\t\t\t// selection changes.\n\t\t\tif ( element.contentEditable !== 'true' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If the selection changes where the active element is a parent of\n\t\t\t// the rich text instance (writing flow), call `onSelectionChange`\n\t\t\t// for the rich text instance that contains the start or end of the\n\t\t\t// selection.\n\t\t\tif ( ownerDocument.activeElement !== element ) {\n\t\t\t\tif ( ! ownerDocument.activeElement.contains( element ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst selection = defaultView.getSelection();\n\t\t\t\tconst { anchorNode, focusNode } = selection;\n\n\t\t\t\tif (\n\t\t\t\t\telement.contains( anchorNode ) &&\n\t\t\t\t\telement !== anchorNode &&\n\t\t\t\t\telement.contains( focusNode ) &&\n\t\t\t\t\telement !== focusNode\n\t\t\t\t) {\n\t\t\t\t\tconst { start, end } = createRecord();\n\t\t\t\t\trecord.current.activeFormats = EMPTY_ACTIVE_FORMATS;\n\t\t\t\t\tonSelectionChange( start, end );\n\t\t\t\t} else if (\n\t\t\t\t\telement.contains( anchorNode ) &&\n\t\t\t\t\telement !== anchorNode\n\t\t\t\t) {\n\t\t\t\t\tconst { start, end: offset = start } = createRecord();\n\t\t\t\t\trecord.current.activeFormats = EMPTY_ACTIVE_FORMATS;\n\t\t\t\t\tonSelectionChange( offset );\n\t\t\t\t} else if (\n\t\t\t\t\telement.contains( focusNode ) &&\n\t\t\t\t\telement !== focusNode\n\t\t\t\t) {\n\t\t\t\t\tconst { start, end: offset = start } = createRecord();\n\t\t\t\t\trecord.current.activeFormats = EMPTY_ACTIVE_FORMATS;\n\t\t\t\t\tonSelectionChange( undefined, offset );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( event.type !== 'selectionchange' && ! isSelected ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case of a keyboard event, ignore selection changes during\n\t\t\t// composition.\n\t\t\tif ( isComposing ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { start, end, text } = createRecord();\n\t\t\tconst oldRecord = record.current;\n\n\t\t\t// Fallback mechanism for IE11, which doesn't support the input event.\n\t\t\t// Any input results in a selection change.\n\t\t\tif ( text !== oldRecord.text ) {\n\t\t\t\tonInput();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( start === oldRecord.start && end === oldRecord.end ) {\n\t\t\t\t// Sometimes the browser may set the selection on the placeholder\n\t\t\t\t// element, in which case the caret is not visible. We need to set\n\t\t\t\t// the caret before the placeholder if that's the case.\n\t\t\t\tif ( oldRecord.text.length === 0 && start === 0 ) {\n\t\t\t\t\tfixPlaceholderSelection( defaultView );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newValue = {\n\t\t\t\t...oldRecord,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\t// _newActiveFormats may be set on arrow key navigation to control\n\t\t\t\t// the right boundary position. If undefined, getActiveFormats will\n\t\t\t\t// give the active formats according to the browser.\n\t\t\t\tactiveFormats: oldRecord._newActiveFormats,\n\t\t\t\t_newActiveFormats: undefined,\n\t\t\t};\n\n\t\t\tconst newActiveFormats = getActiveFormats(\n\t\t\t\tnewValue,\n\t\t\t\tEMPTY_ACTIVE_FORMATS\n\t\t\t);\n\n\t\t\t// Update the value with the new active formats.\n\t\t\tnewValue.activeFormats = newActiveFormats;\n\n\t\t\t// It is important that the internal value is updated first,\n\t\t\t// otherwise the value will be wrong on render!\n\t\t\trecord.current = newValue;\n\t\t\tapplyRecord( newValue, { domOnly: true } );\n\t\t\tonSelectionChange( start, end );\n\t\t}\n\n\t\tfunction onCompositionStart() {\n\t\t\tisComposing = true;\n\t\t\t// Do not update the selection when characters are being composed as\n\t\t\t// this rerenders the component and might destroy internal browser\n\t\t\t// editing state.\n\t\t\townerDocument.removeEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t}\n\n\t\tfunction onCompositionEnd() {\n\t\t\tisComposing = false;\n\t\t\t// Ensure the value is up-to-date for browsers that don't emit a final\n\t\t\t// input event after composition.\n\t\t\tonInput( { inputType: 'insertText' } );\n\t\t\t// Tracking selection changes can be resumed.\n\t\t\townerDocument.addEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t}\n\n\t\tfunction onFocus() {\n\t\t\tconst { record, isSelected, onSelectionChange, applyRecord } =\n\t\t\t\tpropsRef.current;\n\n\t\t\t// When the whole editor is editable, let writing flow handle\n\t\t\t// selection.\n\t\t\tif ( element.parentElement.closest( '[contenteditable=\"true\"]' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ! isSelected ) {\n\t\t\t\t// We know for certain that on focus, the old selection is invalid.\n\t\t\t\t// It will be recalculated on the next mouseup, keyup, or touchend\n\t\t\t\t// event.\n\t\t\t\tconst index = undefined;\n\n\t\t\t\trecord.current = {\n\t\t\t\t\t...record.current,\n\t\t\t\t\tstart: index,\n\t\t\t\t\tend: index,\n\t\t\t\t\tactiveFormats: EMPTY_ACTIVE_FORMATS,\n\t\t\t\t};\n\t\t\t\tonSelectionChange( index, index );\n\t\t\t} else {\n\t\t\t\tapplyRecord( record.current );\n\t\t\t\tonSelectionChange( record.current.start, record.current.end );\n\t\t\t}\n\n\t\t\t// Update selection as soon as possible, which is at the next animation\n\t\t\t// frame. The event listener for selection changes may be added too late\n\t\t\t// at this point, but this focus event is still too early to calculate\n\t\t\t// the selection.\n\t\t\trafId = defaultView.requestAnimationFrame( handleSelectionChange );\n\t\t}\n\n\t\telement.addEventListener( 'input', onInput );\n\t\telement.addEventListener( 'compositionstart', onCompositionStart );\n\t\telement.addEventListener( 'compositionend', onCompositionEnd );\n\t\telement.addEventListener( 'focus', onFocus );\n\t\t// Selection updates must be done at these events as they\n\t\t// happen before the `selectionchange` event. In some cases,\n\t\t// the `selectionchange` event may not even fire, for\n\t\t// example when the window receives focus again on click.\n\t\telement.addEventListener( 'keyup', handleSelectionChange );\n\t\telement.addEventListener( 'mouseup', handleSelectionChange );\n\t\telement.addEventListener( 'touchend', handleSelectionChange );\n\t\townerDocument.addEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'input', onInput );\n\t\t\telement.removeEventListener(\n\t\t\t\t'compositionstart',\n\t\t\t\tonCompositionStart\n\t\t\t);\n\t\t\telement.removeEventListener( 'compositionend', onCompositionEnd );\n\t\t\telement.removeEventListener( 'focus', onFocus );\n\t\t\telement.removeEventListener( 'keyup', handleSelectionChange );\n\t\t\telement.removeEventListener( 'mouseup', handleSelectionChange );\n\t\t\telement.removeEventListener( 'touchend', handleSelectionChange );\n\t\t\townerDocument.removeEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t\tdefaultView.cancelAnimationFrame( rafId );\n\t\t};\n\t}, [] );\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Efficiently updates all the formats from `start` (including) until `end`\n * (excluding) with the active formats. Mutates `value`.\n *\n * @param {Object}        $1         Named paramentes.\n * @param {RichTextValue} $1.value   Value te update.\n * @param {number}        $1.start   Index to update from.\n * @param {number}        $1.end     Index to update until.\n * @param {Array}         $1.formats Replacement formats.\n *\n * @return {RichTextValue} Mutated value.\n */\nexport function updateFormats( { value, start, end, formats } ) {\n\t// Start and end may be switched in case of delete.\n\tconst min = Math.min( start, end );\n\tconst max = Math.max( start, end );\n\tconst formatsBefore = value.formats[ min - 1 ] || [];\n\tconst formatsAfter = value.formats[ max ] || [];\n\n\t// First, fix the references. If any format right before or after are\n\t// equal, the replacement format should use the same reference.\n\tvalue.activeFormats = formats.map( ( format, index ) => {\n\t\tif ( formatsBefore[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsBefore[ index ] ) ) {\n\t\t\t\treturn formatsBefore[ index ];\n\t\t\t}\n\t\t} else if ( formatsAfter[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsAfter[ index ] ) ) {\n\t\t\t\treturn formatsAfter[ index ];\n\t\t\t}\n\t\t}\n\n\t\treturn format;\n\t} );\n\n\twhile ( --end >= start ) {\n\t\tif ( value.activeFormats.length > 0 ) {\n\t\t\tvalue.formats[ end ] = value.activeFormats;\n\t\t} else {\n\t\t\tdelete value.formats[ end ];\n\t\t}\n\t}\n\n\treturn value;\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\nimport { BACKSPACE, DELETE } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { remove } from '../remove';\nimport { removeLineSeparator } from '../remove-line-separator';\nimport { isEmptyLine } from '../is-empty';\n\nexport function useDelete( props ) {\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onKeyDown( event ) {\n\t\t\tconst { keyCode } = event;\n\t\t\tconst { createRecord, handleChange, multilineTag } =\n\t\t\t\tpropsRef.current;\n\n\t\t\tif ( event.defaultPrevented ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( keyCode !== DELETE && keyCode !== BACKSPACE ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentValue = createRecord();\n\t\t\tconst { start, end, text } = currentValue;\n\t\t\tconst isReverse = keyCode === BACKSPACE;\n\n\t\t\t// Always handle full content deletion ourselves.\n\t\t\tif ( start === 0 && end !== 0 && end === text.length ) {\n\t\t\t\thandleChange( remove( currentValue ) );\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( multilineTag ) {\n\t\t\t\tlet newValue;\n\n\t\t\t\t// Check to see if we should remove the first item if empty.\n\t\t\t\tif (\n\t\t\t\t\tisReverse &&\n\t\t\t\t\tcurrentValue.start === 0 &&\n\t\t\t\t\tcurrentValue.end === 0 &&\n\t\t\t\t\tisEmptyLine( currentValue )\n\t\t\t\t) {\n\t\t\t\t\tnewValue = removeLineSeparator( currentValue, ! isReverse );\n\t\t\t\t} else {\n\t\t\t\t\tnewValue = removeLineSeparator( currentValue, isReverse );\n\t\t\t\t}\n\n\t\t\t\tif ( newValue ) {\n\t\t\t\t\thandleChange( newValue );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telement.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef, useLayoutEffect, useReducer } from '@wordpress/element';\nimport { useMergeRefs, useRefEffect } from '@wordpress/compose';\nimport { useRegistry } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { create } from '../create';\nimport { apply } from '../to-dom';\nimport { toHTMLString } from '../to-html-string';\nimport { useDefaultStyle } from './use-default-style';\nimport { useBoundaryStyle } from './use-boundary-style';\nimport { useCopyHandler } from './use-copy-handler';\nimport { useFormatBoundaries } from './use-format-boundaries';\nimport { useSelectObject } from './use-select-object';\nimport { useIndentListItemOnSpace } from './use-indent-list-item-on-space';\nimport { useInputAndSelection } from './use-input-and-selection';\nimport { useDelete } from './use-delete';\nimport { useSpace } from './use-space';\n\nexport function useRichText( {\n\tvalue = '',\n\tselectionStart,\n\tselectionEnd,\n\tplaceholder,\n\tpreserveWhiteSpace,\n\tonSelectionChange,\n\tonChange,\n\t__unstableMultilineTag: multilineTag,\n\t__unstableDisableFormats: disableFormats,\n\t__unstableIsSelected: isSelected,\n\t__unstableDependencies = [],\n\t__unstableAfterParse,\n\t__unstableBeforeSerialize,\n\t__unstableAddInvisibleFormats,\n} ) {\n\tconst registry = useRegistry();\n\tconst [ , forceRender ] = useReducer( () => ( {} ) );\n\tconst ref = useRef();\n\n\tfunction createRecord() {\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\t\tconst range =\n\t\t\tselection.rangeCount > 0 ? selection.getRangeAt( 0 ) : null;\n\n\t\treturn create( {\n\t\t\telement: ref.current,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags:\n\t\t\t\tmultilineTag === 'li' ? [ 'ul', 'ol' ] : undefined,\n\t\t\t__unstableIsEditableTree: true,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\t}\n\n\tfunction applyRecord( newRecord, { domOnly } = {} ) {\n\t\tapply( {\n\t\t\tvalue: newRecord,\n\t\t\tcurrent: ref.current,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags:\n\t\t\t\tmultilineTag === 'li' ? [ 'ul', 'ol' ] : undefined,\n\t\t\tprepareEditableTree: __unstableAddInvisibleFormats,\n\t\t\t__unstableDomOnly: domOnly,\n\t\t\tplaceholder,\n\t\t} );\n\t}\n\n\t// Internal values are updated synchronously, unlike props and state.\n\tconst _value = useRef( value );\n\tconst record = useRef();\n\n\tfunction setRecordFromProps() {\n\t\t_value.current = value;\n\t\trecord.current = create( {\n\t\t\thtml: value,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags:\n\t\t\t\tmultilineTag === 'li' ? [ 'ul', 'ol' ] : undefined,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\t\tif ( disableFormats ) {\n\t\t\trecord.current.formats = Array( value.length );\n\t\t\trecord.current.replacements = Array( value.length );\n\t\t}\n\t\tif ( __unstableAfterParse ) {\n\t\t\trecord.current.formats = __unstableAfterParse( record.current );\n\t\t}\n\t\trecord.current.start = selectionStart;\n\t\trecord.current.end = selectionEnd;\n\t}\n\n\tconst hadSelectionUpdate = useRef( false );\n\n\tif ( ! record.current ) {\n\t\tsetRecordFromProps();\n\t\t// Sometimes formats are added programmatically and we need to make\n\t\t// sure it's persisted to the block store / markup. If these formats\n\t\t// are not applied, they could cause inconsistencies between the data\n\t\t// in the visual editor and the frontend. Right now, it's only relevant\n\t\t// to the `core/text-color` format, which is applied at runtime in\n\t\t// certain circunstances. See the `__unstableFilterAttributeValue`\n\t\t// function in `packages/format-library/src/text-color/index.js`.\n\t\t// @todo find a less-hacky way of solving this.\n\n\t\tconst hasRelevantInitFormat =\n\t\t\trecord.current?.formats[ 0 ]?.[ 0 ]?.type === 'core/text-color';\n\n\t\tif ( hasRelevantInitFormat ) {\n\t\t\thandleChangesUponInit( record.current );\n\t\t}\n\t} else if (\n\t\tselectionStart !== record.current.start ||\n\t\tselectionEnd !== record.current.end\n\t) {\n\t\thadSelectionUpdate.current = isSelected;\n\t\trecord.current = {\n\t\t\t...record.current,\n\t\t\tstart: selectionStart,\n\t\t\tend: selectionEnd,\n\t\t};\n\t}\n\n\t/**\n\t * Sync the value to global state. The node tree and selection will also be\n\t * updated if differences are found.\n\t *\n\t * @param {Object} newRecord The record to sync and apply.\n\t */\n\tfunction handleChange( newRecord ) {\n\t\trecord.current = newRecord;\n\t\tapplyRecord( newRecord );\n\n\t\tif ( disableFormats ) {\n\t\t\t_value.current = newRecord.text;\n\t\t} else {\n\t\t\t_value.current = toHTMLString( {\n\t\t\t\tvalue: __unstableBeforeSerialize\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...newRecord,\n\t\t\t\t\t\t\tformats: __unstableBeforeSerialize( newRecord ),\n\t\t\t\t\t  }\n\t\t\t\t\t: newRecord,\n\t\t\t\tmultilineTag,\n\t\t\t\tpreserveWhiteSpace,\n\t\t\t} );\n\t\t}\n\n\t\tconst { start, end, formats, text } = newRecord;\n\n\t\t// Selection must be updated first, so it is recorded in history when\n\t\t// the content change happens.\n\t\t// We batch both calls to only attempt to rerender once.\n\t\tregistry.batch( () => {\n\t\t\tonSelectionChange( start, end );\n\t\t\tonChange( _value.current, {\n\t\t\t\t__unstableFormats: formats,\n\t\t\t\t__unstableText: text,\n\t\t\t} );\n\t\t} );\n\t\tforceRender();\n\t}\n\n\tfunction handleChangesUponInit( newRecord ) {\n\t\trecord.current = newRecord;\n\n\t\t_value.current = toHTMLString( {\n\t\t\tvalue: __unstableBeforeSerialize\n\t\t\t\t? {\n\t\t\t\t\t\t...newRecord,\n\t\t\t\t\t\tformats: __unstableBeforeSerialize( newRecord ),\n\t\t\t\t  }\n\t\t\t\t: newRecord,\n\t\t\tmultilineTag,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\tconst { formats, text } = newRecord;\n\n\t\tregistry.batch( () => {\n\t\t\tonChange( _value.current, {\n\t\t\t\t__unstableFormats: formats,\n\t\t\t\t__unstableText: text,\n\t\t\t} );\n\t\t} );\n\t\tforceRender();\n\t}\n\n\tfunction applyFromProps() {\n\t\tsetRecordFromProps();\n\t\tapplyRecord( record.current );\n\t}\n\n\tconst didMount = useRef( false );\n\n\t// Value updates must happen synchonously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( didMount.current && value !== _value.current ) {\n\t\t\tapplyFromProps();\n\t\t\tforceRender();\n\t\t}\n\t}, [ value ] );\n\n\t// Value updates must happen synchonously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( ! hadSelectionUpdate.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ref.current.ownerDocument.activeElement !== ref.current ) {\n\t\t\tref.current.focus();\n\t\t}\n\n\t\tapplyFromProps();\n\t\thadSelectionUpdate.current = false;\n\t}, [ hadSelectionUpdate.current ] );\n\n\tconst mergedRefs = useMergeRefs( [\n\t\tref,\n\t\tuseDefaultStyle(),\n\t\tuseBoundaryStyle( { record } ),\n\t\tuseCopyHandler( { record, multilineTag, preserveWhiteSpace } ),\n\t\tuseSelectObject(),\n\t\tuseFormatBoundaries( { record, applyRecord } ),\n\t\tuseDelete( {\n\t\t\tcreateRecord,\n\t\t\thandleChange,\n\t\t\tmultilineTag,\n\t\t} ),\n\t\tuseIndentListItemOnSpace( {\n\t\t\tmultilineTag,\n\t\t\tcreateRecord,\n\t\t\thandleChange,\n\t\t} ),\n\t\tuseInputAndSelection( {\n\t\t\trecord,\n\t\t\tapplyRecord,\n\t\t\tcreateRecord,\n\t\t\thandleChange,\n\t\t\tisSelected,\n\t\t\tonSelectionChange,\n\t\t} ),\n\t\tuseSpace(),\n\t\tuseRefEffect( () => {\n\t\t\tapplyFromProps();\n\t\t\tdidMount.current = true;\n\t\t}, [ placeholder, ...__unstableDependencies ] ),\n\t] );\n\n\treturn {\n\t\tvalue: record.current,\n\t\tonChange: handleChange,\n\t\tref: mergedRefs,\n\t};\n}\n\nexport default function __experimentalRichText() {}\n","/**\n * WordPress dependencies\n */\nimport { useCallback } from '@wordpress/element';\n\n/**\n * In HTML, leading and trailing spaces are not visible, and multiple spaces\n * elsewhere are visually reduced to one space. This rule prevents spaces from\n * collapsing so all space is visible in the editor and can be removed. It also\n * prevents some browsers from inserting non-breaking spaces at the end of a\n * line to prevent the space from visually disappearing. Sometimes these non\n * breaking spaces can linger in the editor causing unwanted non breaking spaces\n * in between words. If also prevent Firefox from inserting a trailing `br` node\n * to visualise any trailing space, causing the element to be saved.\n *\n * > Authors are encouraged to set the 'white-space' property on editing hosts\n * > and on markup that was originally created through these editing mechanisms\n * > to the value 'pre-wrap'. Default HTML whitespace handling is not well\n * > suited to WYSIWYG editing, and line wrapping will not work correctly in\n * > some corner cases if 'white-space' is left at its default value.\n *\n * https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors\n *\n * @type {string}\n */\nconst whiteSpace = 'pre-wrap';\n\n/**\n * A minimum width of 1px will prevent the rich text container from collapsing\n * to 0 width and hiding the caret. This is useful for inline containers.\n */\nconst minWidth = '1px';\n\nexport function useDefaultStyle() {\n\treturn useCallback( ( element ) => {\n\t\tif ( ! element ) return;\n\t\telement.style.whiteSpace = whiteSpace;\n\t\telement.style.minWidth = minWidth;\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRefEffect } from '@wordpress/compose';\n\nexport function useSelectObject() {\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onClick( event ) {\n\t\t\tconst { target } = event;\n\n\t\t\t// If the child element has no text content, it must be an object.\n\t\t\tif ( target === element || target.textContent ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { ownerDocument } = target;\n\t\t\tconst { defaultView } = ownerDocument;\n\t\t\tconst range = ownerDocument.createRange();\n\t\t\tconst selection = defaultView.getSelection();\n\n\t\t\trange.selectNode( target );\n\t\t\tselection.removeAllRanges();\n\t\t\tselection.addRange( range );\n\t\t}\n\n\t\telement.addEventListener( 'click', onClick );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'click', onClick );\n\t\t};\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRefEffect } from '@wordpress/compose';\nimport { SPACE } from '@wordpress/keycodes';\n\n/**\n * For some elements like BUTTON and SUMMARY, the space key doesn't insert a\n * space character in some browsers even though the element is editable. We have\n * to manually insert a space and prevent default behaviour.\n *\n * DO NOT limit this behaviour to specific tag names! It would mean that this\n * behaviour is not widely tested. If there's ever any problems, we should find\n * a different solution entirely or remove it entirely.\n */\nexport function useSpace() {\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onKeyDown( event ) {\n\t\t\t// Don't insert a space if default behaviour is prevented.\n\t\t\tif ( event.defaultPrevented ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { keyCode, altKey, metaKey, ctrlKey, key } = event;\n\n\t\t\t// Only consider the space key without modifiers pressed.\n\t\t\tif ( keyCode !== SPACE || altKey || metaKey || ctrlKey ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Disregard character composition that involves the Space key.\n\t\t\t//\n\t\t\t// @see https://github.com/WordPress/gutenberg/issues/35086\n\t\t\t//\n\t\t\t// For example, to input a standalone diacritic (like ´ or `) using a\n\t\t\t// keyboard with dead keys, one must first press the dead key and then\n\t\t\t// press the Space key.\n\t\t\t//\n\t\t\t// Many operating systems handle this in such a way that the second\n\t\t\t// KeyboardEvent contains the property `keyCode: 229`. According to the\n\t\t\t// spec, 229 allows the system to indicate that an Input Method Editor\n\t\t\t// (IDE) is processing some key input.\n\t\t\t//\n\t\t\t// However, Windows doesn't use `keyCode: 229` for dead key composition,\n\t\t\t// instead emitting an event with values `keyCode: SPACE` and `key: '´'`.\n\t\t\t// That is why checking the `key` property for values other than `SPACE`\n\t\t\t// is important.\n\t\t\t//\n\t\t\t// This should serve as a reminder that the `KeyboardEvent.keyCode`\n\t\t\t// attribute is officially deprecated and that we should consider more\n\t\t\t// consistent interfaces.\n\t\t\tif ( key !== ' ' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.target.ownerDocument.execCommand( 'insertText', false, ' ' );\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\telement.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n","/**\n * Internal dependencies\n */\nimport { getActiveFormat } from '../get-active-format';\nimport { getActiveObject } from '../get-active-object';\n\nexport default function FormatEdit( {\n\tformatTypes,\n\tonChange,\n\tonFocus,\n\tvalue,\n\tforwardedRef,\n} ) {\n\treturn formatTypes.map( ( settings ) => {\n\t\tconst { name, edit: Edit } = settings;\n\n\t\tif ( ! Edit ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst activeFormat = getActiveFormat( value, name );\n\t\tconst isActive = activeFormat !== undefined;\n\t\tconst activeObject = getActiveObject( value );\n\t\tconst isObjectActive =\n\t\t\tactiveObject !== undefined && activeObject.type === name;\n\n\t\treturn (\n\t\t\t<Edit\n\t\t\t\tkey={ name }\n\t\t\t\tisActive={ isActive }\n\t\t\t\tactiveAttributes={\n\t\t\t\t\tisActive ? activeFormat.attributes || {} : {}\n\t\t\t\t}\n\t\t\t\tisObjectActive={ isObjectActive }\n\t\t\t\tactiveObjectAttributes={\n\t\t\t\t\tisObjectActive ? activeObject.attributes || {} : {}\n\t\t\t\t}\n\t\t\t\tvalue={ value }\n\t\t\t\tonChange={ onChange }\n\t\t\t\tonFocus={ onFocus }\n\t\t\t\tcontentRef={ forwardedRef }\n\t\t\t/>\n\t\t);\n\t} );\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","window","combineReducers","formatTypes","state","action","type","keyBy","omit","names","LEAF_KEY","arrayOf","isShallowEqual","a","b","fromIndex","i","length","getFormatTypes","selector","getDependants","rootCache","normalizedGetDependants","getCache","dependants","dependant","map","cache","caches","isUniqueByDependants","has","WeakMap","set","clear","head","createCache","callSelector","node","args","len","arguments","Array","apply","lastDependants","next","prev","val","createSelector","values","getFormatType","name","getFormatTypeForBareElement","bareElementTagName","find","className","tagName","getFormatTypeForClassName","elementClassName","indexOf","addFormatTypes","castArray","removeFormatTypes","store","createReduxStore","reducer","selectors","actions","isFormatEqual","format1","format2","attributes1","attributes","attributes2","keys1","keys","keys2","normaliseFormats","newFormats","formats","slice","forEach","formatsAtIndex","index","formatsAtPreviousIndex","newFormatsAtIndex","format","formatIndex","previousFormat","replace","array","applyFormat","startIndex","start","endIndex","end","activeFormats","startFormat","position","filter","splice","reject","createElement","html","implementation","body","createHTMLDocument","innerHTML","register","LINE_SEPARATOR","OBJECT_REPLACEMENT_CHARACTER","toFormat","formatType","class","select","richTextStore","trim","__experimentalCreatePrepareEditableTree","__experimentalCreateOnChangeEditableValue","registeredAttributes","unregisteredAttributes","_attributes","__unstableFilterAttributeValue","create","element","text","range","multilineTag","multilineWrapperTags","__unstableIsEditableTree","isEditableTree","preserveWhiteSpace","replacements","document","createFromMultilineElement","createFromElement","accumulateSelection","accumulator","parentNode","startContainer","startOffset","endContainer","endOffset","currentLength","undefined","nodeType","TEXT_NODE","childNodes","filterRange","nodeValue","collapseWhiteSpace","string","removeReservedCharacters","RegExp","currentWrapperTags","hasChildNodes","nodeName","toLowerCase","ELEMENT_NODE","getAttribute","encodeURIComponent","mergePair","getAttributes","mergeFormats","from","children","hasAttributes","test","concat","reduce","getActiveFormats","EMPTY_ACTIVE_FORMATS","formatsBefore","formatsAfter","getActiveFormat","getActiveObject","getTextContent","getLineIndex","isListRootSelected","replacement","isActiveListType","rootType","isCollapsed","isEmpty","isEmptyLine","join","separator","accumlator","registerFormatType","settings","console","error","formatTypeForBareElement","formatTypeForClassName","title","keywords","dispatch","removeFormat","filterFormats","insert","valueToInsert","remove","pattern","match","rest","offset","newReplacements","newText","fill","insertLineSeparator","beforeText","previousLineSeparatorIndex","lastIndexOf","previousLineSeparatorFormats","removeLineSeparator","backward","collapsed","newValue","removeStart","removeEnd","insertObject","formatToInsert","split","splitAtSelection","nextStart","substring","before","after","restoreOnAttributes","newAttributes","newKey","startsWith","fromFormat","object","boundaryClass","elementAttributes","isEqualUntil","toTree","createEmpty","append","getLastChild","getParent","isText","getText","appendText","onStartIndex","onEndIndex","placeholder","formatsLength","tree","multilineFormat","deepestActiveFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","character","charAt","shouldInsertPadding","characterFormats","push","pointer","parent","newNode","decodeURIComponent","contenteditable","style","createPathToNode","rootNode","path","previousSibling","getNodeByPath","shift","child","ownerDocument","createTextNode","setAttribute","appendChild","appendData","lastChild","removeChild","toDom","prepareEditableTree","doc","startPath","endPath","selection","current","__unstableDomOnly","applyValue","defaultView","getSelection","createRange","setStart","setEnd","activeElement","rangeCount","getRangeAt","removeAllRanges","addRange","HTMLElement","focus","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","data","replaceChild","currentAttributes","futureAttributes","ii","removeAttribute","toHTMLString","createChildrenHTML","createElementHTML","attributeString","isValidAttributeName","escapeAttribute","escapeEditableHTML","toggleFormat","speak","sprintf","__","unregisterFormatType","oldFormat","canIndentListItems","lineIndex","previousLineIndex","formatsAtLineIndex","formatsAtPreviousLineIndex","canOutdentListItems","indentListItems","rootFormat","targetLevelLineIndex","startFormats","getTargetLevelLineIndex","targetFormats","lastformat","getParentLineIndex","outdentListItems","startingLineIndex","parentFormats","lastChildIndex","lineFormats","childIndex","getLastChildIndex","currentFormats","changeListType","newFormat","startLineFormats","endLineFormats","startCount","endCount","changed","useAnchorRef","ref","activeFormat","useMemo","nextElementSibling","closest","useBoundaryStyle","record","useRef","useEffect","boundarySelector","querySelector","getComputedStyle","color","globalStyleId","globalStyle","getElementById","id","useCopyHandler","props","propsRef","useRefEffect","onCopy","event","contains","selectedRecord","plainText","clipboardData","setData","preventDefault","addEventListener","removeEventListener","useFormatBoundaries","forceRender","useReducer","onKeyDown","keyCode","shiftKey","altKey","metaKey","ctrlKey","LEFT","RIGHT","applyRecord","currentActiveFormats","direction","reverseKey","isReverse","destination","isIncreasing","every","newActiveFormatsLength","_newActiveFormats","newActiveFormats","useIndentListItemOnSpace","createRecord","handleChange","SPACE","currentValue","characterBefore","INSERTION_INPUT_TYPES_TO_IGNORE","Set","useInputAndSelection","rafId","isComposing","onInput","inputType","oldActiveFormats","min","Math","max","updateFormats","handleSelectionChange","isSelected","onSelectionChange","contentEditable","anchorNode","focusNode","oldRecord","anchorOffset","targetNode","collapseToStart","fixPlaceholderSelection","domOnly","onCompositionStart","onCompositionEnd","onFocus","parentElement","requestAnimationFrame","cancelAnimationFrame","useDelete","defaultPrevented","DELETE","BACKSPACE","useRichText","selectionStart","selectionEnd","onChange","__unstableMultilineTag","__unstableDisableFormats","disableFormats","__unstableIsSelected","__unstableDependencies","__unstableAfterParse","__unstableBeforeSerialize","__unstableAddInvisibleFormats","registry","useRegistry","newRecord","_value","setRecordFromProps","hadSelectionUpdate","batch","__unstableFormats","__unstableText","handleChangesUponInit","applyFromProps","didMount","useLayoutEffect","mergedRefs","useMergeRefs","useCallback","whiteSpace","minWidth","onClick","target","textContent","selectNode","execCommand","__experimentalRichText","FormatEdit","forwardedRef","edit","Edit","isActive","activeObject","isObjectActive","activeAttributes","activeObjectAttributes","contentRef"],"sourceRoot":""}